# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2008-2014, the pandas development team
# This file is distributed under the same license as the pandas package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: pandas 0.24.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-04-11 11:49+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../development/internals.rst:3
msgid "{{ header }}"
msgstr ""

#: ../../development/internals.rst:7
msgid "Internals"
msgstr ""

#: ../../development/internals.rst:9
msgid ""
"This section will provide a look into some of pandas internals. It's "
"primarily intended for developers of pandas itself."
msgstr ""

#: ../../development/internals.rst:13
msgid "Indexing"
msgstr ""

#: ../../development/internals.rst:15
msgid ""
"In pandas there are a few objects implemented which can serve as valid "
"containers for the axis labels:"
msgstr ""

#: ../../development/internals.rst:18
msgid ""
"``Index``: the generic \"ordered set\" object, an ndarray of object dtype"
" assuming nothing about its contents. The labels must be hashable (and "
"likely immutable) and unique. Populates a dict of label to location in "
"Cython to do ``O(1)`` lookups."
msgstr ""

#: ../../development/internals.rst:22
msgid ""
"``Int64Index``: a version of ``Index`` highly optimized for 64-bit "
"integer data, such as time stamps"
msgstr ""

#: ../../development/internals.rst:24
msgid ""
"``Float64Index``: a version of ``Index`` highly optimized for 64-bit "
"float data"
msgstr ""

#: ../../development/internals.rst:25
msgid "``MultiIndex``: the standard hierarchical index object"
msgstr ""

#: ../../development/internals.rst:26
msgid ""
"``DatetimeIndex``: An Index object with ``Timestamp`` boxed elements "
"(impl are the int64 values)"
msgstr ""

#: ../../development/internals.rst:27
msgid ""
"``TimedeltaIndex``: An Index object with ``Timedelta`` boxed elements "
"(impl are the in64 values)"
msgstr ""

#: ../../development/internals.rst:28
msgid "``PeriodIndex``: An Index object with Period elements"
msgstr ""

#: ../../development/internals.rst:30
msgid "There are functions that make the creation of a regular index easy:"
msgstr ""

#: ../../development/internals.rst:32
msgid ""
"``date_range``: fixed frequency date range generated from a time rule or "
"DateOffset. An ndarray of Python datetime objects"
msgstr ""

#: ../../development/internals.rst:34
msgid ""
"``period_range``: fixed frequency date range generated from a time rule "
"or DateOffset. An ndarray of ``Period`` objects, representing timespans"
msgstr ""

#: ../../development/internals.rst:37
msgid ""
"The motivation for having an ``Index`` class in the first place was to "
"enable different implementations of indexing. This means that it's "
"possible for you, the user, to implement a custom ``Index`` subclass that"
" may be better suited to a particular application than the ones provided "
"in pandas."
msgstr ""

#: ../../development/internals.rst:42
msgid ""
"From an internal implementation point of view, the relevant methods that "
"an ``Index`` must define are one or more of the following (depending on "
"how incompatible the new object internals are with the ``Index`` "
"functions):"
msgstr ""

#: ../../development/internals.rst:46
msgid ""
"``get_loc``: returns an \"indexer\" (an integer, or in some cases a slice"
" object) for a label"
msgstr ""

#: ../../development/internals.rst:48
msgid "``slice_locs``: returns the \"range\" to slice between two labels"
msgstr ""

#: ../../development/internals.rst:49
msgid ""
"``get_indexer``: Computes the indexing vector for reindexing / data "
"alignment purposes. See the source / docstrings for more on this"
msgstr ""

#: ../../development/internals.rst:51
msgid ""
"``get_indexer_non_unique``: Computes the indexing vector for reindexing /"
" data alignment purposes when the index is non-unique. See the source / "
"docstrings for more on this"
msgstr ""

#: ../../development/internals.rst:54
msgid ""
"``reindex``: Does any pre-conversion of the input index then calls "
"``get_indexer``"
msgstr ""

#: ../../development/internals.rst:56
msgid ""
"``union``, ``intersection``: computes the union or intersection of two "
"Index objects"
msgstr ""

#: ../../development/internals.rst:58
msgid "``insert``: Inserts a new label into an Index, yielding a new object"
msgstr ""

#: ../../development/internals.rst:59
msgid "``delete``: Delete a label, yielding a new object"
msgstr ""

#: ../../development/internals.rst:60
msgid "``drop``: Deletes a set of labels"
msgstr ""

#: ../../development/internals.rst:61
msgid "``take``: Analogous to ndarray.take"
msgstr ""

#: ../../development/internals.rst:64
msgid "MultiIndex"
msgstr ""

#: ../../development/internals.rst:66
msgid ""
"Internally, the ``MultiIndex`` consists of a few things: the **levels**, "
"the integer **codes** (until version 0.24 named *labels*), and the level "
"**names**:"
msgstr ""

#: ../../development/internals.rst:78
msgid ""
"You can probably guess that the codes determine which unique element is "
"identified with that location at each layer of the index. It's important "
"to note that sortedness is determined **solely** from the integer codes "
"and does not check (or care) whether the levels themselves are sorted. "
"Fortunately, the constructors ``from_tuples`` and ``from_arrays`` ensure "
"that this is true, but if you compute the levels and codes yourself, "
"please be careful."
msgstr ""

#: ../../development/internals.rst:86
msgid "Values"
msgstr ""

#: ../../development/internals.rst:88
msgid ""
"Pandas extends NumPy's type system with custom types, like "
"``Categorical`` or datetimes with a timezone, so we have multiple notions"
" of \"values\". For 1-D containers (``Index`` classes and ``Series``) we "
"have the following convention:"
msgstr ""

#: ../../development/internals.rst:92
msgid ""
"``cls._ndarray_values`` is *always* a NumPy ``ndarray``. Ideally, "
"``_ndarray_values`` is cheap to compute. For example, for a "
"``Categorical``, this returns the codes, not the array of objects."
msgstr ""

#: ../../development/internals.rst:95
msgid ""
"``cls._values`` refers is the \"best possible\" array. This could be an "
"``ndarray``, ``ExtensionArray``, or in ``Index`` subclass (note: we're in"
" the process of removing the index subclasses here so that it's always an"
" ``ndarray`` or ``ExtensionArray``)."
msgstr ""

#: ../../development/internals.rst:100
msgid ""
"So, for example, ``Series[category]._values`` is a ``Categorical``, while"
" ``Series[category]._ndarray_values`` is the underlying codes."
msgstr ""

#: ../../development/internals.rst:106
msgid "Subclassing pandas Data Structures"
msgstr ""

#: ../../development/internals.rst:108
msgid "This section has been moved to :ref:`extending.subclassing-pandas`."
msgstr ""

