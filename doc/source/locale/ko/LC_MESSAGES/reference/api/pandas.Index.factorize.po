# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2008-2014, the pandas development team
# This file is distributed under the same license as the pandas package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: pandas 0.24.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-04-11 11:49+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../reference/api/pandas.Index.factorize.rst:2
msgid "pandas.Index.factorize"
msgstr ""

#: of pandas.Index.factorize:2
msgid "Encode the object as an enumerated type or categorical variable."
msgstr ""

#: of pandas.Index.factorize:4
msgid ""
"This method is useful for obtaining a numeric representation of an array "
"when all that matters is identifying distinct values. `factorize` is "
"available as both a top-level function :func:`pandas.factorize`, and as a"
" method :meth:`Series.factorize` and :meth:`Index.factorize`."
msgstr ""

#: of pandas.Index.factorize
msgid "Parameters"
msgstr ""

#: of pandas.Index.factorize:13
msgid "**sort**"
msgstr ""

#: of pandas.Index.factorize:12
msgid "boolean, default False"
msgstr ""

#: of pandas.Index.factorize:12
msgid "Sort `uniques` and shuffle `labels` to maintain the relationship."
msgstr ""

#: of pandas.Index.factorize:16
msgid "**na_sentinel**"
msgstr ""

#: of pandas.Index.factorize:15
msgid "int, default -1"
msgstr ""

#: of pandas.Index.factorize:16
msgid "Value to mark \"not found\"."
msgstr ""

#: of pandas.Index.factorize
msgid "Returns"
msgstr ""

#: of pandas.Index.factorize:22
msgid "**labels**"
msgstr ""

#: of pandas.Index.factorize:21
msgid "ndarray"
msgstr ""

#: of pandas.Index.factorize:21
msgid ""
"An integer ndarray that's an indexer into `uniques`. "
"``uniques.take(labels)`` will have the same values as `values`."
msgstr ""

#: of pandas.Index.factorize:37
msgid "**uniques**"
msgstr ""

#: of pandas.Index.factorize:36
msgid "ndarray, Index, or Categorical"
msgstr ""

#: of pandas.Index.factorize:25
msgid ""
"The unique valid values. When `values` is Categorical, `uniques` is a "
"Categorical. When `values` is some other pandas object, an `Index` is "
"returned. Otherwise, a 1-D ndarray is returned."
msgstr ""

#: of pandas.Index.factorize:31
msgid ""
"Even if there's a missing value in `values`, `uniques` will *not* contain"
" an entry for it."
msgstr ""

#: of pandas.Index.factorize:43
msgid ":obj:`cut`"
msgstr ""

#: of pandas.Index.factorize:43
msgid "Discretize continuous-valued array."
msgstr ""

#: of pandas.Index.factorize:45
msgid ":obj:`unique`"
msgstr ""

#: of pandas.Index.factorize:46
msgid "Find the unique value in an array."
msgstr ""

#: of pandas.Index.factorize:51
msgid "Examples"
msgstr ""

#: of pandas.Index.factorize:52
msgid ""
"These examples all show factorize as a top-level method like "
"``pd.factorize(values)``. The results are identical for methods like "
":meth:`Series.factorize`."
msgstr ""

#: of pandas.Index.factorize:62
msgid ""
"With ``sort=True``, the `uniques` will be sorted, and `labels` will be "
"shuffled so that the relationship is the maintained."
msgstr ""

#: of pandas.Index.factorize:71
msgid ""
"Missing values are indicated in `labels` with `na_sentinel` (``-1`` by "
"default). Note that missing values are never included in `uniques`."
msgstr ""

#: of pandas.Index.factorize:81
msgid ""
"Thus far, we've only factorized lists (which are internally coerced to "
"NumPy arrays). When factorizing pandas objects, the type of `uniques` "
"will differ. For Categoricals, a `Categorical` is returned."
msgstr ""

#: of pandas.Index.factorize:93
msgid ""
"Notice that ``'b'`` is in ``uniques.categories``, despite not being "
"present in ``cat.values``."
msgstr ""

#: of pandas.Index.factorize:96
msgid ""
"For all other pandas objects, an Index of the appropriate type is "
"returned."
msgstr ""

