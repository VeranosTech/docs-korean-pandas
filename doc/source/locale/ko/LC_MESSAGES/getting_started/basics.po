# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2008-2014, the pandas development team
# This file is distributed under the same license as the pandas package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: pandas 0.24.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-04-11 11:49+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../getting_started/basics.rst:3
msgid "{{ header }}"
msgstr ""

#: ../../getting_started/basics.rst:7
msgid "Essential Basic Functionality"
msgstr ""

#: ../../getting_started/basics.rst:9
msgid ""
"Here we discuss a lot of the essential functionality common to the pandas"
" data structures. Here's how to create some of the objects used in the "
"examples from the previous section:"
msgstr ""

#: ../../getting_started/basics.rst:23
msgid "Head and Tail"
msgstr ""

#: ../../getting_started/basics.rst:25
msgid ""
"To view a small sample of a Series or DataFrame object, use the "
":meth:`~DataFrame.head` and :meth:`~DataFrame.tail` methods. The default "
"number of elements to display is five, but you may pass a custom number."
msgstr ""

#: ../../getting_started/basics.rst:38
msgid "Attributes and Underlying Data"
msgstr ""

#: ../../getting_started/basics.rst:40
msgid ""
"pandas objects have a number of attributes enabling you to access the "
"metadata"
msgstr ""

#: ../../getting_started/basics.rst:42
msgid ""
"**shape**: gives the axis dimensions of the object, consistent with "
"ndarray"
msgstr ""

#: ../../getting_started/basics.rst:45
msgid "Axis labels"
msgstr ""

#: ../../getting_started/basics.rst:44
msgid "**Series**: *index* (only axis)"
msgstr ""

#: ../../getting_started/basics.rst:45
msgid "**DataFrame**: *index* (rows) and *columns*"
msgstr ""

#: ../../getting_started/basics.rst:47
msgid "Note, **these attributes can be safely assigned to**!"
msgstr ""

#: ../../getting_started/basics.rst:55
msgid ""
"Pandas objects (:class:`Index`, :class:`Series`, :class:`DataFrame`) can "
"be thought of as containers for arrays, which hold the actual data and do"
" the actual computation. For many types, the underlying array is a "
":class:`numpy.ndarray`. However, pandas and 3rd party libraries may "
"*extend* NumPy's type system to add support for custom arrays (see "
":ref:`basics.dtypes`)."
msgstr ""

#: ../../getting_started/basics.rst:62
msgid ""
"To get the actual data inside a :class:`Index` or :class:`Series`, use "
"the ``.array`` property"
msgstr ""

#: ../../getting_started/basics.rst:70
msgid ""
":attr:`~Series.array` will always be an "
":class:`~pandas.api.extensions.ExtensionArray`. The exact details of what"
" an :class:`~pandas.api.extensions.ExtensionArray` is and why pandas uses"
" them is a bit beyond the scope of this introduction. See "
":ref:`basics.dtypes` for more."
msgstr ""

#: ../../getting_started/basics.rst:74
msgid ""
"If you know you need a NumPy array, use :meth:`~Series.to_numpy` or "
":meth:`numpy.asarray`."
msgstr ""

#: ../../getting_started/basics.rst:82
msgid ""
"When the Series or Index is backed by an "
":class:`~pandas.api.extensions.ExtensionArray`, :meth:`~Series.to_numpy` "
"may involve copying data and coercing values. See :ref:`basics.dtypes` "
"for more."
msgstr ""

#: ../../getting_started/basics.rst:86
msgid ""
":meth:`~Series.to_numpy` gives some control over the ``dtype`` of the "
"resulting :class:`numpy.ndarray`. For example, consider datetimes with "
"timezones. NumPy doesn't have a dtype to represent timezone-aware "
"datetimes, so there are two possibly useful representations:"
msgstr ""

#: ../../getting_started/basics.rst:91
msgid ""
"An object-dtype :class:`numpy.ndarray` with :class:`Timestamp` objects, "
"each with the correct ``tz``"
msgstr ""

#: ../../getting_started/basics.rst:93
msgid ""
"A ``datetime64[ns]`` -dtype :class:`numpy.ndarray`, where the values have"
" been converted to UTC and the timezone discarded"
msgstr ""

#: ../../getting_started/basics.rst:96
msgid "Timezones may be preserved with ``dtype=object``"
msgstr ""

#: ../../getting_started/basics.rst:103
msgid "Or thrown away with ``dtype='datetime64[ns]'``"
msgstr ""

#: ../../getting_started/basics.rst:109
msgid ""
"Getting the \"raw data\" inside a :class:`DataFrame` is possibly a bit "
"more complex. When your ``DataFrame`` only has a single data type for all"
" the columns, :meth:`DataFrame.to_numpy` will return the underlying data:"
msgstr ""

#: ../../getting_started/basics.rst:117
msgid ""
"If a DataFrame contains homogeneously-typed data, the ndarray can "
"actually be modified in-place, and the changes will be reflected in the "
"data structure. For heterogeneous data (e.g. some of the DataFrame's "
"columns are not all the same dtype), this will not be the case. The "
"values attribute itself, unlike the axis labels, cannot be assigned to."
msgstr ""

#: ../../getting_started/basics.rst:125
msgid ""
"When working with heterogeneous data, the dtype of the resulting ndarray "
"will be chosen to accommodate all of the data involved. For example, if "
"strings are involved, the result will be of object dtype. If there are "
"only floats and integers, the resulting array will be of float dtype."
msgstr ""

#: ../../getting_started/basics.rst:130
msgid ""
"In the past, pandas recommended :attr:`Series.values` or "
":attr:`DataFrame.values` for extracting the data from a Series or "
"DataFrame. You'll still find references to these in old code bases and "
"online. Going forward, we recommend avoiding ``.values`` and using "
"``.array`` or ``.to_numpy()``. ``.values`` has the following drawbacks:"
msgstr ""

#: ../../getting_started/basics.rst:136
msgid ""
"When your Series contains an :ref:`extension type <extending.extension-"
"types>`, it's unclear whether :attr:`Series.values` returns a NumPy array"
" or the extension array. :attr:`Series.array` will always return an "
":class:`~pandas.api.extensions.ExtensionArray`, and will never copy data."
" :meth:`Series.to_numpy` will always return a NumPy array, potentially at"
" the cost of copying / coercing values."
msgstr ""

#: ../../getting_started/basics.rst:141
msgid ""
"When your DataFrame contains a mixture of data types, "
":attr:`DataFrame.values` may involve copying data and coercing values to "
"a common dtype, a relatively expensive operation. "
":meth:`DataFrame.to_numpy`, being a method, makes it clearer that the "
"returned NumPy array may not be a view on the same data in the DataFrame."
msgstr ""

#: ../../getting_started/basics.rst:149
msgid "Accelerated operations"
msgstr ""

#: ../../getting_started/basics.rst:151
msgid ""
"pandas has support for accelerating certain types of binary numerical and"
" boolean operations using the ``numexpr`` library and the ``bottleneck`` "
"libraries."
msgstr ""

#: ../../getting_started/basics.rst:154
msgid ""
"These libraries are especially useful when dealing with large data sets, "
"and provide large speedups. ``numexpr`` uses smart chunking, caching, and"
" multiple cores. ``bottleneck`` is a set of specialized cython routines "
"that are especially fast when dealing with arrays that have ``nans``."
msgstr ""

#: ../../getting_started/basics.rst:159
msgid "Here is a sample (using 100 column x 100,000 row ``DataFrames``):"
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "Operation"
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "0.11.0 (ms)"
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "Prior Version (ms)"
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "Ratio to Prior"
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "``df1 > df2``"
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "13.32"
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "125.35"
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "0.1063"
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "``df1 * df2``"
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "21.71"
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "36.63"
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "0.5928"
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "``df1 + df2``"
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "22.04"
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "36.50"
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "0.6039"
msgstr ""

#: ../../getting_started/basics.rst:170
msgid ""
"You are highly encouraged to install both libraries. See the section "
":ref:`Recommended Dependencies <install.recommended_dependencies>` for "
"more installation info."
msgstr ""

#: ../../getting_started/basics.rst:173
msgid ""
"These are both enabled to be used by default, you can control this by "
"setting the options:"
msgstr ""

#: ../../getting_started/basics.rst:185
msgid "Flexible binary operations"
msgstr ""

#: ../../getting_started/basics.rst:187
msgid ""
"With binary operations between pandas data structures, there are two key "
"points of interest:"
msgstr ""

#: ../../getting_started/basics.rst:190
msgid ""
"Broadcasting behavior between higher- (e.g. DataFrame) and lower-"
"dimensional (e.g. Series) objects."
msgstr ""

#: ../../getting_started/basics.rst:192
msgid "Missing data in computations."
msgstr ""

#: ../../getting_started/basics.rst:194
msgid ""
"We will demonstrate how to manage these issues independently, though they"
" can be handled simultaneously."
msgstr ""

#: ../../getting_started/basics.rst:198
msgid "Matching / broadcasting behavior"
msgstr ""

#: ../../getting_started/basics.rst:200
msgid ""
"DataFrame has the methods :meth:`~DataFrame.add`, :meth:`~DataFrame.sub`,"
" :meth:`~DataFrame.mul`, :meth:`~DataFrame.div` and related functions "
":meth:`~DataFrame.radd`, :meth:`~DataFrame.rsub`, ... for carrying out "
"binary operations. For broadcasting behavior, Series input is of primary "
"interest. Using these functions, you can use to either match on the "
"*index* or *columns* via the **axis** keyword:"
msgstr ""

#: ../../getting_started/basics.rst:228
msgid ""
"Furthermore you can align a level of a MultiIndexed DataFrame with a "
"Series."
msgstr ""

#: ../../getting_started/basics.rst:238
msgid ""
"Series and Index also support the :func:`divmod` builtin. This function "
"takes the floor division and modulo operation at the same time returning "
"a two-tuple of the same type as the left hand side. For example:"
msgstr ""

#: ../../getting_started/basics.rst:256
msgid "We can also do elementwise :func:`divmod`:"
msgstr ""

#: ../../getting_started/basics.rst:265
msgid "Missing data / operations with fill values"
msgstr ""

#: ../../getting_started/basics.rst:267
msgid ""
"In Series and DataFrame, the arithmetic functions have the option of "
"inputting a *fill_value*, namely a value to substitute when at most one "
"of the values at a location are missing. For example, when adding two "
"DataFrame objects, you may wish to treat NaN as 0 unless both DataFrames "
"are missing that value, in which case the result will be NaN (you can "
"later replace NaN with some other value using ``fillna`` if you wish)."
msgstr ""

#: ../../getting_started/basics.rst:290
msgid "Flexible Comparisons"
msgstr ""

#: ../../getting_started/basics.rst:292
msgid ""
"Series and DataFrame have the binary comparison methods ``eq``, ``ne``, "
"``lt``, ``gt``, ``le``, and ``ge`` whose behavior is analogous to the "
"binary arithmetic operations described above:"
msgstr ""

#: ../../getting_started/basics.rst:301
msgid ""
"These operations produce a pandas object of the same type as the left-"
"hand-side input that is of dtype ``bool``. These ``boolean`` objects can "
"be used in indexing operations, see the section on :ref:`Boolean "
"indexing<indexing.boolean>`."
msgstr ""

#: ../../getting_started/basics.rst:308
msgid "Boolean Reductions"
msgstr ""

#: ../../getting_started/basics.rst:310
msgid ""
"You can apply the reductions: :attr:`~DataFrame.empty`, "
":meth:`~DataFrame.any`, :meth:`~DataFrame.all`, and "
":meth:`~DataFrame.bool` to provide a way to summarize a boolean result."
msgstr ""

#: ../../getting_started/basics.rst:319
msgid "You can reduce to a final boolean value."
msgstr ""

#: ../../getting_started/basics.rst:325
msgid ""
"You can test if a pandas object is empty, via the "
":attr:`~DataFrame.empty` property."
msgstr ""

#: ../../getting_started/basics.rst:332
msgid ""
"To evaluate single-element pandas objects in a boolean context, use the "
"method :meth:`~DataFrame.bool`:"
msgstr ""

#: ../../getting_started/basics.rst:344
msgid "You might be tempted to do the following:"
msgstr ""

#: ../../getting_started/basics.rst:351
msgid "Or"
msgstr ""

#: ../../getting_started/basics.rst:357
msgid ""
"These will both raise errors, as you are trying to compare multiple "
"values.::"
msgstr ""

#: ../../getting_started/basics.rst:361
msgid "See :ref:`gotchas<gotchas.truth>` for a more detailed discussion."
msgstr ""

#: ../../getting_started/basics.rst:366
msgid "Comparing if objects are equivalent"
msgstr ""

#: ../../getting_started/basics.rst:368
msgid ""
"Often you may find that there is more than one way to compute the same "
"result.  As a simple example, consider ``df + df`` and ``df * 2``. To "
"test that these two computations produce the same result, given the tools"
" shown above, you might imagine using ``(df + df == df * 2).all()``. But "
"in fact, this expression is False:"
msgstr ""

#: ../../getting_started/basics.rst:379
msgid ""
"Notice that the boolean DataFrame ``df + df == df * 2`` contains some "
"False values! This is because NaNs do not compare as equals:"
msgstr ""

#: ../../getting_started/basics.rst:386
msgid ""
"So, NDFrames (such as Series and DataFrames) have an "
":meth:`~DataFrame.equals` method for testing equality, with NaNs in "
"corresponding locations treated as equal."
msgstr ""

#: ../../getting_started/basics.rst:394
msgid ""
"Note that the Series or DataFrame index needs to be in the same order for"
" equality to be True:"
msgstr ""

#: ../../getting_started/basics.rst:405
msgid "Comparing array-like objects"
msgstr ""

#: ../../getting_started/basics.rst:407
msgid ""
"You can conveniently perform element-wise comparisons when comparing a "
"pandas data structure with a scalar value:"
msgstr ""

#: ../../getting_started/basics.rst:415
msgid ""
"Pandas also handles element-wise comparisons between different array-like"
" objects of the same length:"
msgstr ""

#: ../../getting_started/basics.rst:423
msgid ""
"Trying to compare ``Index`` or ``Series`` objects of different lengths "
"will raise a ValueError:"
msgstr ""

#: ../../getting_started/basics.rst:434
msgid ""
"Note that this is different from the NumPy behavior where a comparison "
"can be broadcast:"
msgstr ""

#: ../../getting_started/basics.rst:441
msgid "or it can return False if broadcasting can not be done:"
msgstr ""

#: ../../getting_started/basics.rst:449
msgid "Combining overlapping data sets"
msgstr ""

#: ../../getting_started/basics.rst:451
msgid ""
"A problem occasionally arising is the combination of two similar data "
"sets where values in one are preferred over the other. An example would "
"be two data series representing a particular economic indicator where one"
" is considered to be of \"higher quality\". However, the lower quality "
"series might extend further back in history or have more complete data "
"coverage. As such, we would like to combine two DataFrame objects where "
"missing values in one DataFrame are conditionally filled with like-"
"labeled values from the other DataFrame. The function implementing this "
"operation is :meth:`~DataFrame.combine_first`, which we illustrate:"
msgstr ""

#: ../../getting_started/basics.rst:472
msgid "General DataFrame Combine"
msgstr ""

#: ../../getting_started/basics.rst:474
msgid ""
"The :meth:`~DataFrame.combine_first` method above calls the more general "
":meth:`DataFrame.combine`. This method takes another DataFrame and a "
"combiner function, aligns the input DataFrame and then passes the "
"combiner function pairs of Series (i.e., columns whose names are the "
"same)."
msgstr ""

#: ../../getting_started/basics.rst:479
msgid "So, for instance, to reproduce :meth:`~DataFrame.combine_first` as above:"
msgstr ""

#: ../../getting_started/basics.rst:490
msgid "Descriptive statistics"
msgstr ""

#: ../../getting_started/basics.rst:492
msgid ""
"There exists a large number of methods for computing descriptive "
"statistics and other related operations on :ref:`Series "
"<api.series.stats>`, :ref:`DataFrame <api.dataframe.stats>`. Most of "
"these are aggregations (hence producing a lower-dimensional result) like "
":meth:`~DataFrame.sum`, :meth:`~DataFrame.mean`, and "
":meth:`~DataFrame.quantile`, but some of them, like "
":meth:`~DataFrame.cumsum` and :meth:`~DataFrame.cumprod`, produce an "
"object of the same size. Generally speaking, these methods take an "
"**axis** argument, just like *ndarray.{sum, std, ...}*, but the axis can "
"be specified by name or integer:"
msgstr ""

#: ../../getting_started/basics.rst:502
msgid "**Series**: no axis argument needed"
msgstr ""

#: ../../getting_started/basics.rst:503
msgid "**DataFrame**: \"index\" (axis=0, default), \"columns\" (axis=1)"
msgstr ""

#: ../../getting_started/basics.rst:505 ../../getting_started/basics.rst:1536
msgid "For example:"
msgstr ""

#: ../../getting_started/basics.rst:513
msgid ""
"All such methods have a ``skipna`` option signaling whether to exclude "
"missing data (``True`` by default):"
msgstr ""

#: ../../getting_started/basics.rst:521
msgid ""
"Combined with the broadcasting / arithmetic behavior, one can describe "
"various statistical procedures, like standardization (rendering data zero"
" mean and standard deviation 1), very concisely:"
msgstr ""

#: ../../getting_started/basics.rst:532
msgid ""
"Note that methods like :meth:`~DataFrame.cumsum` and "
":meth:`~DataFrame.cumprod` preserve the location of ``NaN`` values. This "
"is somewhat different from :meth:`~DataFrame.expanding` and "
":meth:`~DataFrame.rolling`. For more details please see :ref:`this note "
"<stats.moments.expanding.note>`."
msgstr ""

#: ../../getting_started/basics.rst:541
msgid ""
"Here is a quick reference summary table of common functions. Each also "
"takes an optional ``level`` parameter which applies only if the object "
"has a :ref:`hierarchical index<advanced.hierarchical>`."
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "Function"
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "Description"
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "``count``"
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "Number of non-NA observations"
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "``sum``"
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "Sum of values"
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "``mean``"
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "Mean of values"
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "``mad``"
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "Mean absolute deviation"
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "``median``"
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "Arithmetic median of values"
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "``min``"
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "Minimum"
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "``max``"
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "Maximum"
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "``mode``"
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "Mode"
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "``abs``"
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "Absolute Value"
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "``prod``"
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "Product of values"
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "``std``"
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "Bessel-corrected sample standard deviation"
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "``var``"
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "Unbiased variance"
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "``sem``"
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "Standard error of the mean"
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "``skew``"
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "Sample skewness (3rd moment)"
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "``kurt``"
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "Sample kurtosis (4th moment)"
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "``quantile``"
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "Sample quantile (value at %)"
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "``cumsum``"
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "Cumulative sum"
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "``cumprod``"
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "Cumulative product"
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "``cummax``"
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "Cumulative maximum"
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "``cummin``"
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "Cumulative minimum"
msgstr ""

#: ../../getting_started/basics.rst:570
msgid ""
"Note that by chance some NumPy methods, like ``mean``, ``std``, and "
"``sum``, will exclude NAs on Series input by default:"
msgstr ""

#: ../../getting_started/basics.rst:578
msgid ""
":meth:`Series.nunique` will return the number of unique non-NA values in "
"a Series:"
msgstr ""

#: ../../getting_started/basics.rst:591
msgid "Summarizing data: describe"
msgstr ""

#: ../../getting_started/basics.rst:593
msgid ""
"There is a convenient :meth:`~DataFrame.describe` function which computes"
" a variety of summary statistics about a Series or the columns of a "
"DataFrame (excluding NAs of course):"
msgstr ""

#: ../../getting_started/basics.rst:607
msgid "You can select specific percentiles to include in the output:"
msgstr ""

#: ../../getting_started/basics.rst:613
msgid "By default, the median is always included."
msgstr ""

#: ../../getting_started/basics.rst:615
msgid ""
"For a non-numerical Series object, :meth:`~Series.describe` will give a "
"simple summary of the number of unique values and most frequently "
"occurring values:"
msgstr ""

#: ../../getting_started/basics.rst:623
msgid ""
"Note that on a mixed-type DataFrame object, :meth:`~DataFrame.describe` "
"will restrict the summary to include only numerical columns or, if none "
"are, only categorical columns:"
msgstr ""

#: ../../getting_started/basics.rst:632
msgid ""
"This behavior can be controlled by providing a list of types as "
"``include``/``exclude`` arguments. The special value ``all`` can also be "
"used:"
msgstr ""

#: ../../getting_started/basics.rst:641
msgid ""
"That feature relies on :ref:`select_dtypes <basics.selectdtypes>`. Refer "
"to there for details about accepted inputs."
msgstr ""

#: ../../getting_started/basics.rst:647
msgid "Index of Min/Max Values"
msgstr ""

#: ../../getting_started/basics.rst:649
msgid ""
"The :meth:`~DataFrame.idxmin` and :meth:`~DataFrame.idxmax` functions on "
"Series and DataFrame compute the index labels with the minimum and "
"maximum corresponding values:"
msgstr ""

#: ../../getting_started/basics.rst:664
msgid ""
"When there are multiple rows (or columns) matching the minimum or maximum"
" value, :meth:`~DataFrame.idxmin` and :meth:`~DataFrame.idxmax` return "
"the first matching index:"
msgstr ""

#: ../../getting_started/basics.rst:676
msgid "``idxmin`` and ``idxmax`` are called ``argmin`` and ``argmax`` in NumPy."
msgstr ""

#: ../../getting_started/basics.rst:681
msgid "Value counts (histogramming) / Mode"
msgstr ""

#: ../../getting_started/basics.rst:683
msgid ""
"The :meth:`~Series.value_counts` Series method and top-level function "
"computes a histogram of a 1D array of values. It can also be used as a "
"function on regular arrays:"
msgstr ""

#: ../../getting_started/basics.rst:694
msgid ""
"Similarly, you can get the most frequently occurring value(s) (the mode) "
"of the values in a Series or DataFrame:"
msgstr ""

#: ../../getting_started/basics.rst:706
msgid "Discretization and quantiling"
msgstr ""

#: ../../getting_started/basics.rst:708
msgid ""
"Continuous values can be discretized using the :func:`cut` (bins based on"
" values) and :func:`qcut` (bins based on sample quantiles) functions:"
msgstr ""

#: ../../getting_started/basics.rst:720
msgid ""
":func:`qcut` computes sample quantiles. For example, we could slice up "
"some normally distributed data into equal-size quartiles like so:"
msgstr ""

#: ../../getting_started/basics.rst:730
msgid "We can also pass infinite values to define the bins:"
msgstr ""

#: ../../getting_started/basics.rst:741
msgid "Function application"
msgstr ""

#: ../../getting_started/basics.rst:743
msgid ""
"To apply your own or another library's functions to pandas objects, you "
"should be aware of the three methods below. The appropriate method to use"
" depends on whether your function expects to operate on an entire "
"``DataFrame`` or ``Series``, row- or column-wise, or elementwise."
msgstr ""

#: ../../getting_started/basics.rst:748
msgid "`Tablewise Function Application`_: :meth:`~DataFrame.pipe`"
msgstr ""

#: ../../getting_started/basics.rst:749
msgid "`Row or Column-wise Function Application`_: :meth:`~DataFrame.apply`"
msgstr ""

#: ../../getting_started/basics.rst:750
msgid ""
"`Aggregation API`_: :meth:`~DataFrame.agg` and "
":meth:`~DataFrame.transform`"
msgstr ""

#: ../../getting_started/basics.rst:751
msgid "`Applying Elementwise Functions`_: :meth:`~DataFrame.applymap`"
msgstr ""

#: ../../getting_started/basics.rst:756
msgid "Tablewise Function Application"
msgstr ""

#: ../../getting_started/basics.rst:758
msgid ""
"``DataFrames`` and ``Series`` can of course just be passed into "
"functions. However, if the function needs to be called in a chain, "
"consider using the :meth:`~DataFrame.pipe` method. Compare the following"
msgstr ""

#: ../../getting_started/basics.rst:767
msgid "with the equivalent"
msgstr ""

#: ../../getting_started/basics.rst:775
msgid ""
"Pandas encourages the second style, which is known as method chaining. "
"``pipe`` makes it easy to use your own or another library's functions in "
"method chains, alongside pandas' methods."
msgstr ""

#: ../../getting_started/basics.rst:779
msgid ""
"In the example above, the functions ``f``, ``g``, and ``h`` each expected"
" the ``DataFrame`` as the first positional argument. What if the function"
" you wish to apply takes its data as, say, the second argument? In this "
"case, provide ``pipe`` with a tuple of ``(callable, data_keyword)``. "
"``.pipe`` will route the ``DataFrame`` to the argument specified in the "
"tuple."
msgstr ""

#: ../../getting_started/basics.rst:784
msgid ""
"For example, we can fit a regression using statsmodels. Their API expects"
" a formula first and a ``DataFrame`` as the second argument, ``data``. We"
" pass in the function, keyword pair ``(sm.ols, 'data')`` to ``pipe``:"
msgstr ""

#: ../../getting_started/basics.rst:799
msgid ""
"The pipe method is inspired by unix pipes and more recently dplyr_ and "
"magrittr_, which have introduced the popular ``(%>%)`` (read pipe) "
"operator for R_. The implementation of ``pipe`` here is quite clean and "
"feels right at home in python. We encourage you to view the source code "
"of :meth:`~DataFrame.pipe`."
msgstr ""

#: ../../getting_started/basics.rst:810
msgid "Row or Column-wise Function Application"
msgstr ""

#: ../../getting_started/basics.rst:812
msgid ""
"Arbitrary functions can be applied along the axes of a DataFrame using "
"the :meth:`~DataFrame.apply` method, which, like the descriptive "
"statistics methods, takes an optional ``axis`` argument:"
msgstr ""

#: ../../getting_started/basics.rst:824
msgid ""
"The :meth:`~DataFrame.apply` method will also dispatch on a string method"
" name."
msgstr ""

#: ../../getting_started/basics.rst:831
msgid ""
"The return type of the function passed to :meth:`~DataFrame.apply` "
"affects the type of the final output from ``DataFrame.apply`` for the "
"default behaviour:"
msgstr ""

#: ../../getting_started/basics.rst:834
msgid ""
"If the applied function returns a ``Series``, the final output is a "
"``DataFrame``. The columns match the index of the ``Series`` returned by "
"the applied function."
msgstr ""

#: ../../getting_started/basics.rst:836
msgid ""
"If the applied function returns any other type, the final output is a "
"``Series``."
msgstr ""

#: ../../getting_started/basics.rst:838
msgid ""
"This default behaviour can be overridden using the ``result_type``, which"
" accepts three options: ``reduce``, ``broadcast``, and ``expand``. These "
"will determine how list-likes return values expand (or not) to a "
"``DataFrame``."
msgstr ""

#: ../../getting_started/basics.rst:842
msgid ""
":meth:`~DataFrame.apply` combined with some cleverness can be used to "
"answer many questions about a data set. For example, suppose we wanted to"
" extract the date where the maximum value for each column occurred:"
msgstr ""

#: ../../getting_started/basics.rst:852
msgid ""
"You may also pass additional arguments and keyword arguments to the "
":meth:`~DataFrame.apply` method. For instance, consider the following "
"function you would like to apply:"
msgstr ""

#: ../../getting_started/basics.rst:860
msgid "You may then apply this function as follows:"
msgstr ""

#: ../../getting_started/basics.rst:866
msgid ""
"Another useful feature is the ability to pass Series methods to carry out"
" some Series operation on each column or row:"
msgstr ""

#: ../../getting_started/basics.rst:882
msgid ""
"Finally, :meth:`~DataFrame.apply` takes an argument ``raw`` which is "
"False by default, which converts each row or column into a Series before "
"applying the function. When set to True, the passed function will instead"
" receive an ndarray object, which has positive performance implications "
"if you do not need the indexing functionality."
msgstr ""

#: ../../getting_started/basics.rst:891
msgid "Aggregation API"
msgstr ""

#: ../../getting_started/basics.rst:895
msgid ""
"The aggregation API allows one to express possibly multiple aggregation "
"operations in a single concise way. This API is similar across pandas "
"objects, see :ref:`groupby API <groupby.aggregate>`, the :ref:`window "
"functions API <stats.aggregate>`, and the :ref:`resample API "
"<timeseries.aggregate>`. The entry point for aggregation is "
":meth:`DataFrame.aggregate`, or the alias :meth:`DataFrame.agg`."
msgstr ""

#: ../../getting_started/basics.rst:901
msgid "We will use a similar starting frame from above:"
msgstr ""

#: ../../getting_started/basics.rst:910
msgid ""
"Using a single function is equivalent to :meth:`~DataFrame.apply`. You "
"can also pass named methods as strings. These will return a ``Series`` of"
" the aggregated output:"
msgstr ""

#: ../../getting_started/basics.rst:924
msgid "Single aggregations on a ``Series`` this will return a scalar value:"
msgstr ""

#: ../../getting_started/basics.rst:932
msgid "Aggregating with multiple functions"
msgstr ""

#: ../../getting_started/basics.rst:934
msgid ""
"You can pass multiple aggregation arguments as a list. The results of "
"each of the passed functions will be a row in the resulting "
"``DataFrame``. These are naturally named from the aggregation function."
msgstr ""

#: ../../getting_started/basics.rst:942
msgid "Multiple functions yield multiple rows:"
msgstr ""

#: ../../getting_started/basics.rst:948
msgid ""
"On a ``Series``, multiple functions return a ``Series``, indexed by the "
"function names:"
msgstr ""

#: ../../getting_started/basics.rst:954
msgid "Passing a ``lambda`` function will yield a ``<lambda>`` named row:"
msgstr ""

#: ../../getting_started/basics.rst:960
msgid "Passing a named function will yield that name for the row:"
msgstr ""

#: ../../getting_started/basics.rst:970
msgid "Aggregating with a dict"
msgstr ""

#: ../../getting_started/basics.rst:972
msgid ""
"Passing a dictionary of column names to a scalar or a list of scalars, to"
" ``DataFrame.agg`` allows you to customize which functions are applied to"
" which columns. Note that the results are not in any particular order, "
"you can use an ``OrderedDict`` instead to guarantee ordering."
msgstr ""

#: ../../getting_started/basics.rst:980
msgid ""
"Passing a list-like will generate a ``DataFrame`` output. You will get a "
"matrix-like output of all of the aggregators. The output will consist of "
"all unique functions. Those that are not noted for a particular column "
"will be ``NaN``:"
msgstr ""

#: ../../getting_started/basics.rst:991
msgid "Mixed Dtypes"
msgstr ""

#: ../../getting_started/basics.rst:993
msgid ""
"When presented with mixed dtypes that cannot aggregate, ``.agg`` will "
"only take the valid aggregations. This is similar to how groupby ``.agg``"
" works."
msgstr ""

#: ../../getting_started/basics.rst:1011
msgid "Custom describe"
msgstr ""

#: ../../getting_started/basics.rst:1013
msgid ""
"With ``.agg()`` is it possible to easily create a custom describe "
"function, similar to the built in :ref:`describe function "
"<basics.describe>`."
msgstr ""

#: ../../getting_started/basics.rst:1030
msgid "Transform API"
msgstr ""

#: ../../getting_started/basics.rst:1034
msgid ""
"The :meth:`~DataFrame.transform` method returns an object that is indexed"
" the same (same size) as the original. This API allows you to provide "
"*multiple* operations at the same time rather than one-by-one. Its API is"
" quite similar to the ``.agg`` API."
msgstr ""

#: ../../getting_started/basics.rst:1038
msgid "We create a frame similar to the one used in the above sections."
msgstr ""

#: ../../getting_started/basics.rst:1047
msgid ""
"Transform the entire frame. ``.transform()`` allows input functions as: a"
" NumPy function, a string function name or a user defined function."
msgstr ""

#: ../../getting_started/basics.rst:1057
msgid ""
"Here :meth:`~DataFrame.transform` received a single function; this is "
"equivalent to a ufunc application."
msgstr ""

#: ../../getting_started/basics.rst:1063
msgid ""
"Passing a single function to ``.transform()`` with a ``Series`` will "
"yield a single ``Series`` in return."
msgstr ""

#: ../../getting_started/basics.rst:1071
msgid "Transform with multiple functions"
msgstr ""

#: ../../getting_started/basics.rst:1073
msgid ""
"Passing multiple functions will yield a column MultiIndexed DataFrame. "
"The first level will be the original frame column names; the second level"
" will be the names of the transforming functions."
msgstr ""

#: ../../getting_started/basics.rst:1081
msgid ""
"Passing multiple functions to a Series will yield a DataFrame. The "
"resulting column names will be the transforming functions."
msgstr ""

#: ../../getting_started/basics.rst:1090
msgid "Transforming with a dict"
msgstr ""

#: ../../getting_started/basics.rst:1093
msgid "Passing a dict of functions will allow selective transforming per column."
msgstr ""

#: ../../getting_started/basics.rst:1099
msgid ""
"Passing a dict of lists will generate a MultiIndexed DataFrame with these"
" selective transforms."
msgstr ""

#: ../../getting_started/basics.rst:1110
msgid "Applying Elementwise Functions"
msgstr ""

#: ../../getting_started/basics.rst:1112
msgid ""
"Since not all functions can be vectorized (accept NumPy arrays and return"
" another array or value), the methods :meth:`~DataFrame.applymap` on "
"DataFrame and analogously :meth:`~Series.map` on Series accept any Python"
" function taking a single value and returning a single value. For "
"example:"
msgstr ""

#: ../../getting_started/basics.rst:1132
msgid ""
":meth:`Series.map` has an additional feature; it can be used to easily "
"\"link\" or \"map\" values defined by a secondary series. This is closely"
" related to :ref:`merging/joining functionality <merging>`:"
msgstr ""

#: ../../getting_started/basics.rst:1148
msgid "Reindexing and altering labels"
msgstr ""

#: ../../getting_started/basics.rst:1150
msgid ""
":meth:`~Series.reindex` is the fundamental data alignment method in "
"pandas. It is used to implement nearly all other features relying on "
"label-alignment functionality. To *reindex* means to conform the data to "
"match a given set of labels along a particular axis. This accomplishes "
"several things:"
msgstr ""

#: ../../getting_started/basics.rst:1155
msgid "Reorders the existing data to match a new set of labels"
msgstr ""

#: ../../getting_started/basics.rst:1156
msgid ""
"Inserts missing value (NA) markers in label locations where no data for "
"that label existed"
msgstr ""

#: ../../getting_started/basics.rst:1158
msgid ""
"If specified, **fill** data for missing labels using logic (highly "
"relevant to working with time series data)"
msgstr ""

#: ../../getting_started/basics.rst:1161
msgid "Here is a simple example:"
msgstr ""

#: ../../getting_started/basics.rst:1169
msgid ""
"Here, the ``f`` label was not contained in the Series and hence appears "
"as ``NaN`` in the result."
msgstr ""

#: ../../getting_started/basics.rst:1172
msgid "With a DataFrame, you can simultaneously reindex the index and columns:"
msgstr ""

#: ../../getting_started/basics.rst:1179
msgid "You may also use ``reindex`` with an ``axis`` keyword:"
msgstr ""

#: ../../getting_started/basics.rst:1185
msgid ""
"Note that the ``Index`` objects containing the actual axis labels can be "
"**shared** between objects. So if we have a Series and a DataFrame, the "
"following can be done:"
msgstr ""

#: ../../getting_started/basics.rst:1195
msgid ""
"This means that the reindexed Series's index is the same Python object as"
" the DataFrame's index."
msgstr ""

#: ../../getting_started/basics.rst:1200
msgid ""
":meth:`DataFrame.reindex` also supports an \"axis-style\" calling "
"convention, where you specify a single ``labels`` argument and the "
"``axis`` it applies to."
msgstr ""

#: ../../getting_started/basics.rst:1210
msgid ""
":ref:`MultiIndex / Advanced Indexing <advanced>` is an even more concise "
"way of doing reindexing."
msgstr ""

#: ../../getting_started/basics.rst:1215
msgid ""
"When writing performance-sensitive code, there is a good reason to spend "
"some time becoming a reindexing ninja: **many operations are faster on "
"pre-aligned data**. Adding two unaligned DataFrames internally triggers a"
" reindexing step. For exploratory analysis you will hardly notice the "
"difference (because ``reindex`` has been heavily optimized), but when CPU"
" cycles matter sprinkling a few explicit ``reindex`` calls here and there"
" can have an impact."
msgstr ""

#: ../../getting_started/basics.rst:1226
msgid "Reindexing to align with another object"
msgstr ""

#: ../../getting_started/basics.rst:1228
msgid ""
"You may wish to take an object and reindex its axes to be labeled the "
"same as another object. While the syntax for this is straightforward "
"albeit verbose, it is a common enough operation that the "
":meth:`~DataFrame.reindex_like` method is available to make this simpler:"
msgstr ""

#: ../../getting_started/basics.rst:1249
msgid "Aligning objects with each other with ``align``"
msgstr ""

#: ../../getting_started/basics.rst:1251
msgid ""
"The :meth:`~Series.align` method is the fastest way to simultaneously "
"align two objects. It supports a ``join`` argument (related to "
":ref:`joining and merging <merging>`):"
msgstr ""

#: ../../getting_started/basics.rst:1254
msgid "``join='outer'``: take the union of the indexes (default)"
msgstr ""

#: ../../getting_started/basics.rst:1255
msgid "``join='left'``: use the calling object's index"
msgstr ""

#: ../../getting_started/basics.rst:1256
msgid "``join='right'``: use the passed object's index"
msgstr ""

#: ../../getting_started/basics.rst:1257
msgid "``join='inner'``: intersect the indexes"
msgstr ""

#: ../../getting_started/basics.rst:1259
msgid "It returns a tuple with both of the reindexed Series:"
msgstr ""

#: ../../getting_started/basics.rst:1272
msgid ""
"For DataFrames, the join method will be applied to both the index and the"
" columns by default:"
msgstr ""

#: ../../getting_started/basics.rst:1279
msgid "You can also pass an ``axis`` option to only align on the specified axis:"
msgstr ""

#: ../../getting_started/basics.rst:1287
msgid ""
"If you pass a Series to :meth:`DataFrame.align`, you can choose to align "
"both objects either on the DataFrame's index or columns using the "
"``axis`` argument:"
msgstr ""

#: ../../getting_started/basics.rst:1297
msgid "Filling while reindexing"
msgstr ""

#: ../../getting_started/basics.rst:1299
msgid ""
":meth:`~Series.reindex` takes an optional parameter ``method`` which is a"
" filling method chosen from the following table:"
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "Method"
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "Action"
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "pad / ffill"
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "Fill values forward"
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "bfill / backfill"
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "Fill values backward"
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "nearest"
msgstr ""

#: ../../getting_started/basics.rst:1
msgid "Fill from the nearest index value"
msgstr ""

#: ../../getting_started/basics.rst:1310
msgid "We illustrate these fill methods on a simple Series:"
msgstr ""

#: ../../getting_started/basics.rst:1325
msgid ""
"These methods require that the indexes are **ordered** increasing or "
"decreasing."
msgstr ""

#: ../../getting_started/basics.rst:1328
msgid ""
"Note that the same result could have been achieved using :ref:`fillna "
"<missing_data.fillna>` (except for ``method='nearest'``) or "
":ref:`interpolate <missing_data.interpolate>`:"
msgstr ""

#: ../../getting_started/basics.rst:1336
msgid ""
":meth:`~Series.reindex` will raise a ValueError if the index is not "
"monotonically increasing or decreasing. :meth:`~Series.fillna` and "
":meth:`~Series.interpolate` will not perform any checks on the order of "
"the index."
msgstr ""

#: ../../getting_started/basics.rst:1343
msgid "Limits on filling while reindexing"
msgstr ""

#: ../../getting_started/basics.rst:1345
msgid ""
"The ``limit`` and ``tolerance`` arguments provide additional control over"
" filling while reindexing. Limit specifies the maximum count of "
"consecutive matches:"
msgstr ""

#: ../../getting_started/basics.rst:1353
msgid ""
"In contrast, tolerance specifies the maximum distance between the index "
"and indexer values:"
msgstr ""

#: ../../getting_started/basics.rst:1360
msgid ""
"Notice that when used on a ``DatetimeIndex``, ``TimedeltaIndex`` or "
"``PeriodIndex``, ``tolerance`` will coerced into a ``Timedelta`` if "
"possible. This allows you to specify tolerance with appropriate strings."
msgstr ""

#: ../../getting_started/basics.rst:1367
msgid "Dropping labels from an axis"
msgstr ""

#: ../../getting_started/basics.rst:1369
msgid ""
"A method closely related to ``reindex`` is the :meth:`~DataFrame.drop` "
"function. It removes a set of labels from an axis:"
msgstr ""

#: ../../getting_started/basics.rst:1378
msgid "Note that the following also works, but is a bit less obvious / clean:"
msgstr ""

#: ../../getting_started/basics.rst:1387
msgid "Renaming / mapping labels"
msgstr ""

#: ../../getting_started/basics.rst:1389
msgid ""
"The :meth:`~DataFrame.rename` method allows you to relabel an axis based "
"on some mapping (a dict or Series) or an arbitrary function."
msgstr ""

#: ../../getting_started/basics.rst:1397
msgid ""
"If you pass a function, it must return a value when called with any of "
"the labels (and must produce a set of unique values). A dict or Series "
"can also be used:"
msgstr ""

#: ../../getting_started/basics.rst:1406
msgid ""
"If the mapping doesn't include a column/index label, it isn't renamed. "
"Note that extra labels in the mapping don't throw an error."
msgstr ""

#: ../../getting_started/basics.rst:1411
msgid ""
":meth:`DataFrame.rename` also supports an \"axis-style\" calling "
"convention, where you specify a single ``mapper`` and the ``axis`` to "
"apply that mapping to."
msgstr ""

#: ../../getting_started/basics.rst:1420
msgid ""
"The :meth:`~DataFrame.rename` method also provides an ``inplace`` named "
"parameter that is by default ``False`` and copies the underlying data. "
"Pass ``inplace=True`` to rename the data in place."
msgstr ""

#: ../../getting_started/basics.rst:1426
msgid ""
"Finally, :meth:`~Series.rename` also accepts a scalar or list-like for "
"altering the ``Series.name`` attribute."
msgstr ""

#: ../../getting_started/basics.rst:1437
msgid ""
"The methods :meth:`~DataFrame.rename_axis` and "
":meth:`~Series.rename_axis` allow specific names of a `MultiIndex` to be "
"changed (as opposed to the labels)."
msgstr ""

#: ../../getting_started/basics.rst:1454
msgid "Iteration"
msgstr ""

#: ../../getting_started/basics.rst:1456
msgid ""
"The behavior of basic iteration over pandas objects depends on the type. "
"When iterating over a Series, it is regarded as array-like, and basic "
"iteration produces the values. Other data structures, like DataFrame, "
"follow the dict-like convention of iterating over the \"keys\" of the "
"objects."
msgstr ""

#: ../../getting_started/basics.rst:1462
msgid "In short, basic iteration (``for i in object``) produces:"
msgstr ""

#: ../../getting_started/basics.rst:1464
msgid "**Series**: values"
msgstr ""

#: ../../getting_started/basics.rst:1465
msgid "**DataFrame**: column labels"
msgstr ""

#: ../../getting_started/basics.rst:1467
msgid "Thus, for example, iterating over a DataFrame gives you the column names:"
msgstr ""

#: ../../getting_started/basics.rst:1478
msgid ""
"Pandas objects also have the dict-like :meth:`~DataFrame.iteritems` "
"method to iterate over the (key, value) pairs."
msgstr ""

#: ../../getting_started/basics.rst:1481
msgid ""
"To iterate over the rows of a DataFrame, you can use the following "
"methods:"
msgstr ""

#: ../../getting_started/basics.rst:1483
msgid ""
":meth:`~DataFrame.iterrows`: Iterate over the rows of a DataFrame as "
"(index, Series) pairs. This converts the rows to Series objects, which "
"can change the dtypes and has some performance implications."
msgstr ""

#: ../../getting_started/basics.rst:1486
msgid ""
":meth:`~DataFrame.itertuples`: Iterate over the rows of a DataFrame as "
"namedtuples of the values.  This is a lot faster than "
":meth:`~DataFrame.iterrows`, and is in most cases preferable to use to "
"iterate over the values of a DataFrame."
msgstr ""

#: ../../getting_started/basics.rst:1493
msgid ""
"Iterating through pandas objects is generally **slow**. In many cases, "
"iterating manually over the rows is not needed and can be avoided with "
"one of the following approaches:"
msgstr ""

#: ../../getting_started/basics.rst:1497
msgid ""
"Look for a *vectorized* solution: many operations can be performed using "
"built-in methods or NumPy functions, (boolean) indexing, ..."
msgstr ""

#: ../../getting_started/basics.rst:1500
msgid ""
"When you have a function that cannot work on the full DataFrame/Series at"
" once, it is better to use :meth:`~DataFrame.apply` instead of iterating "
"over the values. See the docs on :ref:`function application "
"<basics.apply>`."
msgstr ""

#: ../../getting_started/basics.rst:1504
msgid ""
"If you need to do iterative manipulations on the values but performance "
"is important, consider writing the inner loop with cython or numba. See "
"the :ref:`enhancing performance <enhancingperf>` section for some "
"examples of this approach."
msgstr ""

#: ../../getting_started/basics.rst:1511
msgid ""
"You should **never modify** something you are iterating over. This is not"
" guaranteed to work in all cases. Depending on the data types, the "
"iterator returns a copy and not a view, and writing to it will have no "
"effect!"
msgstr ""

#: ../../getting_started/basics.rst:1516
msgid "For example, in the following case setting the value has no effect:"
msgstr ""

#: ../../getting_started/basics.rst:1528
msgid "iteritems"
msgstr ""

#: ../../getting_started/basics.rst:1530
msgid ""
"Consistent with the dict-like interface, :meth:`~DataFrame.iteritems` "
"iterates through key-value pairs:"
msgstr ""

#: ../../getting_started/basics.rst:1533
msgid "**Series**: (index, scalar value) pairs"
msgstr ""

#: ../../getting_started/basics.rst:1534
msgid "**DataFrame**: (column, Series) pairs"
msgstr ""

#: ../../getting_started/basics.rst:1547
msgid "iterrows"
msgstr ""

#: ../../getting_started/basics.rst:1549
msgid ""
":meth:`~DataFrame.iterrows` allows you to iterate through the rows of a "
"DataFrame as Series objects. It returns an iterator yielding each index "
"value along with a Series containing the data in each row:"
msgstr ""

#: ../../getting_started/basics.rst:1560
msgid ""
"Because :meth:`~DataFrame.iterrows` returns a Series for each row, it "
"does **not** preserve dtypes across the rows (dtypes are preserved across"
" columns for DataFrames). For example,"
msgstr ""

#: ../../getting_started/basics.rst:1571
msgid ""
"All values in ``row``, returned as a Series, are now upcasted to floats, "
"also the original integer value in column `x`:"
msgstr ""

#: ../../getting_started/basics.rst:1579
msgid ""
"To preserve dtypes while iterating over the rows, it is better to use "
":meth:`~DataFrame.itertuples` which returns namedtuples of the values and"
" which is generally much faster than :meth:`~DataFrame.iterrows`."
msgstr ""

#: ../../getting_started/basics.rst:1583
msgid "For instance, a contrived way to transpose the DataFrame would be:"
msgstr ""

#: ../../getting_started/basics.rst:1595
msgid "itertuples"
msgstr ""

#: ../../getting_started/basics.rst:1597
msgid ""
"The :meth:`~DataFrame.itertuples` method will return an iterator yielding"
" a namedtuple for each row in the DataFrame. The first element of the "
"tuple will be the row's corresponding index value, while the remaining "
"values are the row values."
msgstr ""

#: ../../getting_started/basics.rst:1602
msgid "For instance:"
msgstr ""

#: ../../getting_started/basics.rst:1609
msgid ""
"This method does not convert the row to a Series object; it merely "
"returns the values inside a namedtuple. Therefore, "
":meth:`~DataFrame.itertuples` preserves the data type of the values and "
"is generally faster as :meth:`~DataFrame.iterrows`."
msgstr ""

#: ../../getting_started/basics.rst:1616
msgid ""
"The column names will be renamed to positional names if they are invalid "
"Python identifiers, repeated, or start with an underscore. With a large "
"number of columns (>255), regular tuples are returned."
msgstr ""

#: ../../getting_started/basics.rst:1623
msgid ".dt accessor"
msgstr ""

#: ../../getting_started/basics.rst:1625
msgid ""
"``Series`` has an accessor to succinctly return datetime like properties "
"for the *values* of the Series, if it is a datetime/period like Series. "
"This will return a Series, indexed like the existing Series."
msgstr ""

#: ../../getting_started/basics.rst:1638
msgid "This enables nice expressions like this:"
msgstr ""

#: ../../getting_started/basics.rst:1644
msgid "You can easily produces tz aware transformations:"
msgstr ""

#: ../../getting_started/basics.rst:1652
msgid "You can also chain these types of operations:"
msgstr ""

#: ../../getting_started/basics.rst:1658
msgid ""
"You can also format datetime values as strings with "
":meth:`Series.dt.strftime` which supports the same format as the standard"
" :meth:`~datetime.datetime.strftime`."
msgstr ""

#: ../../getting_started/basics.rst:1675
msgid "The ``.dt`` accessor works for period and timedelta dtypes."
msgstr ""

#: ../../getting_started/basics.rst:1696
msgid ""
"``Series.dt`` will raise a ``TypeError`` if you access with a non-"
"datetime-like values."
msgstr ""

#: ../../getting_started/basics.rst:1699
msgid "Vectorized string methods"
msgstr ""

#: ../../getting_started/basics.rst:1701
msgid ""
"Series is equipped with a set of string processing methods that make it "
"easy to operate on each element of the array. Perhaps most importantly, "
"these methods exclude missing/NA values automatically. These are accessed"
" via the Series's ``str`` attribute and generally have names matching the"
" equivalent (scalar) built-in string methods. For example:"
msgstr ""

#: ../../getting_started/basics.rst:1712
msgid ""
"Powerful pattern-matching methods are provided as well, but note that "
"pattern-matching generally uses `regular expressions "
"<https://docs.python.org/3/library/re.html>`__ by default (and in some "
"cases always uses them)."
msgstr ""

#: ../../getting_started/basics.rst:1717
msgid ""
"Please see :ref:`Vectorized String Methods <text.string_methods>` for a "
"complete description."
msgstr ""

#: ../../getting_started/basics.rst:1723
msgid "Sorting"
msgstr ""

#: ../../getting_started/basics.rst:1725
msgid ""
"Pandas supports three kinds of sorting: sorting by index labels, sorting "
"by column values, and sorting by a combination of both."
msgstr ""

#: ../../getting_started/basics.rst:1731
msgid "By Index"
msgstr ""

#: ../../getting_started/basics.rst:1733
msgid ""
"The :meth:`Series.sort_index` and :meth:`DataFrame.sort_index` methods "
"are used to sort a pandas object by its index levels."
msgstr ""

#: ../../getting_started/basics.rst:1758
msgid "By Values"
msgstr ""

#: ../../getting_started/basics.rst:1760
msgid ""
"The :meth:`Series.sort_values` method is used to sort a `Series` by its "
"values. The :meth:`DataFrame.sort_values` method is used to sort a "
"`DataFrame` by its column or row values. The optional ``by`` parameter to"
" :meth:`DataFrame.sort_values` may used to specify one or more columns to"
" use to determine the sorted order."
msgstr ""

#: ../../getting_started/basics.rst:1772
msgid "The ``by`` parameter can take a list of column names, e.g.:"
msgstr ""

#: ../../getting_started/basics.rst:1778
msgid ""
"These methods have special treatment of NA values via the ``na_position``"
" argument:"
msgstr ""

#: ../../getting_started/basics.rst:1790
msgid "By Indexes and Values"
msgstr ""

#: ../../getting_started/basics.rst:1794
msgid ""
"Strings passed as the ``by`` parameter to :meth:`DataFrame.sort_values` "
"may refer to either columns or index level names."
msgstr ""

#: ../../getting_started/basics.rst:1809
msgid "Sort by 'second' (index) and 'A' (column)"
msgstr ""

#: ../../getting_started/basics.rst:1817
msgid ""
"If a string matches both a column name and an index level name then a "
"warning is issued and the column takes precedence. This will result in an"
" ambiguity error in a future version."
msgstr ""

#: ../../getting_started/basics.rst:1824
msgid "searchsorted"
msgstr ""

#: ../../getting_started/basics.rst:1826
msgid ""
"Series has the :meth:`~Series.searchsorted` method, which works similarly"
" to :meth:`numpy.ndarray.searchsorted`."
msgstr ""

#: ../../getting_started/basics.rst:1842
msgid "smallest / largest values"
msgstr ""

#: ../../getting_started/basics.rst:1844
msgid ""
"``Series`` has the :meth:`~Series.nsmallest` and :meth:`~Series.nlargest`"
" methods which return the smallest or largest :math:`n` values. For a "
"large ``Series`` this can be much faster than sorting the entire Series "
"and calling ``head(n)`` on the result."
msgstr ""

#: ../../getting_started/basics.rst:1856
msgid "``DataFrame`` also has the ``nlargest`` and ``nsmallest`` methods."
msgstr ""

#: ../../getting_started/basics.rst:1872
msgid "Sorting by a MultiIndex column"
msgstr ""

#: ../../getting_started/basics.rst:1874
msgid ""
"You must be explicit about sorting when the column is a MultiIndex, and "
"fully specify all levels to ``by``."
msgstr ""

#: ../../getting_started/basics.rst:1886
msgid "Copying"
msgstr ""

#: ../../getting_started/basics.rst:1888
msgid ""
"The :meth:`~DataFrame.copy` method on pandas objects copies the "
"underlying data (though not the axis indexes, since they are immutable) "
"and returns a new object. Note that **it is seldom necessary to copy "
"objects**. For example, there are only a handful of ways to alter a "
"DataFrame *in-place*:"
msgstr ""

#: ../../getting_started/basics.rst:1893
msgid "Inserting, deleting, or modifying a column."
msgstr ""

#: ../../getting_started/basics.rst:1894
msgid "Assigning to the ``index`` or ``columns`` attributes."
msgstr ""

#: ../../getting_started/basics.rst:1895
msgid ""
"For homogeneous data, directly modifying the values via the ``values`` "
"attribute or advanced indexing."
msgstr ""

#: ../../getting_started/basics.rst:1898
msgid ""
"To be clear, no pandas method has the side effect of modifying your data;"
" almost every method returns a new object, leaving the original object "
"untouched. If the data is modified, it is because you did so explicitly."
msgstr ""

#: ../../getting_started/basics.rst:1905
msgid "dtypes"
msgstr ""

#: ../../getting_started/basics.rst:1907
msgid ""
"For the most part, pandas uses NumPy arrays and dtypes for Series or "
"individual columns of a DataFrame. NumPy provides support for ``float``, "
"``int``, ``bool``, ``timedelta64[ns]`` and ``datetime64[ns]`` (note that "
"NumPy does not support timezone-aware datetimes)."
msgstr ""

#: ../../getting_started/basics.rst:1912
msgid ""
"Pandas and third-party libraries *extend* NumPy's type system in a few "
"places. This section describes the extensions pandas has made internally."
" See :ref:`extending.extension-types` for how to write your own extension"
" that works with pandas. See :ref:`ecosystem.extensions` for a list of "
"third-party libraries that have implemented an extension."
msgstr ""

#: ../../getting_started/basics.rst:1918
msgid ""
"The following table lists all of pandas extension types. See the "
"respective documentation sections for more on each type."
msgstr ""

#: ../../getting_started/basics.rst:1922
msgid "Kind of Data"
msgstr ""

#: ../../getting_started/basics.rst:1922
msgid "Data Type"
msgstr ""

#: ../../getting_started/basics.rst:1922
msgid "Scalar"
msgstr ""

#: ../../getting_started/basics.rst:1922
msgid "Array"
msgstr ""

#: ../../getting_started/basics.rst:1922
msgid "Documentation"
msgstr ""

#: ../../getting_started/basics.rst:1924
msgid "tz-aware datetime"
msgstr ""

#: ../../getting_started/basics.rst:1924
msgid ":class:`DatetimeTZDtype`"
msgstr ""

#: ../../getting_started/basics.rst:1924
msgid ":class:`Timestamp`"
msgstr ""

#: ../../getting_started/basics.rst:1924
msgid ":class:`arrays.DatetimeArray`"
msgstr ""

#: ../../getting_started/basics.rst:1924
msgid ":ref:`timeseries.timezone`"
msgstr ""

#: ../../getting_started/basics.rst:1925
msgid "Categorical"
msgstr ""

#: ../../getting_started/basics.rst:1925
msgid ":class:`CategoricalDtype`"
msgstr ""

#: ../../getting_started/basics.rst:1925 ../../getting_started/basics.rst:1927
#: ../../getting_started/basics.rst:1929
msgid "(none)"
msgstr ""

#: ../../getting_started/basics.rst:1925
msgid ":class:`Categorical`"
msgstr ""

#: ../../getting_started/basics.rst:1925
msgid ":ref:`categorical`"
msgstr ""

#: ../../getting_started/basics.rst:1926
msgid "period (time spans)"
msgstr ""

#: ../../getting_started/basics.rst:1926
msgid ":class:`PeriodDtype`"
msgstr ""

#: ../../getting_started/basics.rst:1926
msgid ":class:`Period`"
msgstr ""

#: ../../getting_started/basics.rst:1926
msgid ":class:`arrays.PeriodArray`"
msgstr ""

#: ../../getting_started/basics.rst:1926
msgid ":ref:`timeseries.periods`"
msgstr ""

#: ../../getting_started/basics.rst:1927
msgid "sparse"
msgstr ""

#: ../../getting_started/basics.rst:1927
msgid ":class:`SparseDtype`"
msgstr ""

#: ../../getting_started/basics.rst:1927
msgid ":class:`arrays.SparseArray`"
msgstr ""

#: ../../getting_started/basics.rst:1927
msgid ":ref:`sparse`"
msgstr ""

#: ../../getting_started/basics.rst:1928
msgid "intervals"
msgstr ""

#: ../../getting_started/basics.rst:1928
msgid ":class:`IntervalDtype`"
msgstr ""

#: ../../getting_started/basics.rst:1928
msgid ":class:`Interval`"
msgstr ""

#: ../../getting_started/basics.rst:1928
msgid ":class:`arrays.IntervalArray`"
msgstr ""

#: ../../getting_started/basics.rst:1928
msgid ":ref:`advanced.intervalindex`"
msgstr ""

#: ../../getting_started/basics.rst:1929
msgid "nullable integer"
msgstr ""

#: ../../getting_started/basics.rst:1929
msgid ":class:`Int64Dtype`, ..."
msgstr ""

#: ../../getting_started/basics.rst:1929
msgid ":class:`arrays.IntegerArray`"
msgstr ""

#: ../../getting_started/basics.rst:1929
msgid ":ref:`integer_na`"
msgstr ""

#: ../../getting_started/basics.rst:1932
msgid "Pandas uses the ``object`` dtype for storing strings."
msgstr ""

#: ../../getting_started/basics.rst:1934
msgid ""
"Finally, arbitrary objects may be stored using the ``object`` dtype, but "
"should be avoided to the extent possible (for performance and "
"interoperability with other libraries and methods. See "
":ref:`basics.object_conversion`)."
msgstr ""

#: ../../getting_started/basics.rst:1938
msgid ""
"A convenient :attr:`~DataFrame.dtypes` attribute for DataFrame returns a "
"Series with the data type of each column."
msgstr ""

#: ../../getting_started/basics.rst:1953
msgid "On a ``Series`` object, use the :attr:`~Series.dtype` attribute."
msgstr ""

#: ../../getting_started/basics.rst:1959
msgid ""
"If a pandas object contains data with multiple dtypes *in a single "
"column*, the dtype of the column will be chosen to accommodate all of the"
" data types (``object`` is the most general)."
msgstr ""

#: ../../getting_started/basics.rst:1971
msgid ""
"The number of columns of each type in a ``DataFrame`` can be found by "
"calling :meth:`~DataFrame.get_dtype_counts`."
msgstr ""

#: ../../getting_started/basics.rst:1978
msgid ""
"Numeric dtypes will propagate and can coexist in DataFrames. If a dtype "
"is passed (either directly via the ``dtype`` keyword, a passed "
"``ndarray``, or a passed ``Series``, then it will be preserved in "
"DataFrame operations. Furthermore, different numeric dtypes will **NOT** "
"be combined. The following example will give you a taste."
msgstr ""

#: ../../getting_started/basics.rst:1996
msgid "defaults"
msgstr ""

#: ../../getting_started/basics.rst:1998
msgid ""
"By default integer types are ``int64`` and float types are ``float64``, "
"*regardless* of platform (32-bit or 64-bit). The following will all "
"result in ``int64`` dtypes."
msgstr ""

#: ../../getting_started/basics.rst:2008
msgid ""
"Note that Numpy will choose *platform-dependent* types when creating "
"arrays. The following **WILL** result in ``int32`` on 32-bit platform."
msgstr ""

#: ../../getting_started/basics.rst:2017
msgid "upcasting"
msgstr ""

#: ../../getting_started/basics.rst:2019
msgid ""
"Types can potentially be *upcasted* when combined with other types, "
"meaning they are promoted from the current type (e.g. ``int`` to "
"``float``)."
msgstr ""

#: ../../getting_started/basics.rst:2028
msgid ""
":meth:`DataFrame.to_numpy` will return the *lower-common-denominator* of "
"the dtypes, meaning the dtype that can accommodate **ALL** of the types "
"in the resulting homogeneous dtyped NumPy array. This can force some "
"*upcasting*."
msgstr ""

#: ../../getting_started/basics.rst:2037
msgid "astype"
msgstr ""

#: ../../getting_started/basics.rst:2041
msgid ""
"You can use the :meth:`~DataFrame.astype` method to explicitly convert "
"dtypes from one to another. These will by default return a copy, even if "
"the dtype was unchanged (pass ``copy=False`` to change this behavior). In"
" addition, they will raise an exception if the astype operation is "
"invalid."
msgstr ""

#: ../../getting_started/basics.rst:2045
msgid ""
"Upcasting is always according to the **numpy** rules. If two different "
"dtypes are involved in an operation, then the more *general* one will be "
"used as the result of the operation."
msgstr ""

#: ../../getting_started/basics.rst:2057
msgid ""
"Convert a subset of columns to a specified type using "
":meth:`~DataFrame.astype`."
msgstr ""

#: ../../getting_started/basics.rst:2068
msgid ""
"Convert certain columns to a specific dtype by passing a dict to "
":meth:`~DataFrame.astype`."
msgstr ""

#: ../../getting_started/basics.rst:2079
msgid ""
"When trying to convert a subset of columns to a specified type using "
":meth:`~DataFrame.astype`  and :meth:`~DataFrame.loc`, upcasting occurs."
msgstr ""

#: ../../getting_started/basics.rst:2081
msgid ""
":meth:`~DataFrame.loc` tries to fit in what we are assigning to the "
"current dtypes, while ``[]`` will overwrite them taking the dtype from "
"the right hand side. Therefore the following piece of code produces the "
"unintended result."
msgstr ""

#: ../../getting_started/basics.rst:2093
msgid "object conversion"
msgstr ""

#: ../../getting_started/basics.rst:2095
msgid ""
"pandas offers various functions to try to force conversion of types from "
"the ``object`` dtype to other types. In cases where the data is already "
"of the correct type, but stored in an ``object`` array, the "
":meth:`DataFrame.infer_objects` and :meth:`Series.infer_objects` methods "
"can be used to soft convert to the correct type."
msgstr ""

#: ../../getting_started/basics.rst:2111
msgid ""
"Because the data was transposed the original inference stored all columns"
" as object, which ``infer_objects`` will correct."
msgstr ""

#: ../../getting_started/basics.rst:2118
msgid ""
"The following functions are available for one dimensional object arrays "
"or scalars to perform hard conversion of objects to a specified type:"
msgstr ""

#: ../../getting_started/basics.rst:2121
msgid ":meth:`~pandas.to_numeric` (conversion to numeric dtypes)"
msgstr ""

#: ../../getting_started/basics.rst:2128
msgid ":meth:`~pandas.to_datetime` (conversion to datetime objects)"
msgstr ""

#: ../../getting_started/basics.rst:2136
msgid ":meth:`~pandas.to_timedelta` (conversion to timedelta objects)"
msgstr ""

#: ../../getting_started/basics.rst:2143
msgid ""
"To force a conversion, we can pass in an ``errors`` argument, which "
"specifies how pandas should deal with elements that cannot be converted "
"to desired dtype or object. By default, ``errors='raise'``, meaning that "
"any errors encountered will be raised during the conversion process. "
"However, if ``errors='coerce'``, these errors will be ignored and pandas "
"will convert problematic elements to ``pd.NaT`` (for datetime and "
"timedelta) or ``np.nan`` (for numeric). This might be useful if you are "
"reading in data which is mostly of the desired dtype (e.g. numeric, "
"datetime), but occasionally has non-conforming elements intermixed that "
"you want to represent as missing:"
msgstr ""

#: ../../getting_started/basics.rst:2162
msgid ""
"The ``errors`` parameter has a third option of ``errors='ignore'``, which"
" will simply return the passed in data if it encounters any errors with "
"the conversion to a desired data type:"
msgstr ""

#: ../../getting_started/basics.rst:2177
msgid ""
"In addition to object conversion, :meth:`~pandas.to_numeric` provides "
"another argument ``downcast``, which gives the option of downcasting the "
"newly (or already) numeric data to a smaller dtype, which can conserve "
"memory:"
msgstr ""

#: ../../getting_started/basics.rst:2188
msgid ""
"As these methods apply only to one-dimensional arrays, lists or scalars; "
"they cannot be used directly on multi-dimensional objects such as "
"DataFrames. However, with :meth:`~pandas.DataFrame.apply`, we can "
"\"apply\" the function over each column efficiently:"
msgstr ""

#: ../../getting_started/basics.rst:2208
msgid "gotchas"
msgstr ""

#: ../../getting_started/basics.rst:2210
msgid ""
"Performing selection operations on ``integer`` type data can easily "
"upcast the data to ``floating``. The dtype of the input data will be "
"preserved in cases where ``nans`` are not introduced. See also "
":ref:`Support for integer NA <gotchas.intna>`."
msgstr ""

#: ../../getting_started/basics.rst:2225
msgid "While float dtypes are unchanged."
msgstr ""

#: ../../getting_started/basics.rst:2238
msgid "Selecting columns based on ``dtype``"
msgstr ""

#: ../../getting_started/basics.rst:2242
msgid ""
"The :meth:`~DataFrame.select_dtypes` method implements subsetting of "
"columns based on their ``dtype``."
msgstr ""

#: ../../getting_started/basics.rst:2245
msgid "First, let's create a :class:`DataFrame` with a slew of different dtypes:"
msgstr ""

#: ../../getting_started/basics.rst:2264
msgid "And the dtypes:"
msgstr ""

#: ../../getting_started/basics.rst:2270
msgid ""
":meth:`~DataFrame.select_dtypes` has two parameters ``include`` and "
"``exclude`` that allow you to say \"give me the columns *with* these "
"dtypes\" (``include``) and/or \"give the columns *without* these dtypes\""
" (``exclude``)."
msgstr ""

#: ../../getting_started/basics.rst:2274
msgid "For example, to select ``bool`` columns:"
msgstr ""

#: ../../getting_started/basics.rst:2280
msgid ""
"You can also pass the name of a dtype in the `NumPy dtype hierarchy "
"<https://docs.scipy.org/doc/numpy/reference/arrays.scalars.html>`__:"
msgstr ""

#: ../../getting_started/basics.rst:2287
msgid ""
":meth:`~pandas.DataFrame.select_dtypes` also works with generic dtypes as"
" well."
msgstr ""

#: ../../getting_started/basics.rst:2289
msgid ""
"For example, to select all numeric and boolean columns while excluding "
"unsigned integers:"
msgstr ""

#: ../../getting_started/basics.rst:2296
msgid "To select string columns you must use the ``object`` dtype:"
msgstr ""

#: ../../getting_started/basics.rst:2302
msgid ""
"To see all the child dtypes of a generic ``dtype`` like ``numpy.number`` "
"you can define a function that returns a tree of child dtypes:"
msgstr ""

#: ../../getting_started/basics.rst:2313
msgid "All NumPy dtypes are subclasses of ``numpy.generic``:"
msgstr ""

#: ../../getting_started/basics.rst:2321
msgid ""
"Pandas also defines the types ``category``, and ``datetime64[ns, tz]``, "
"which are not integrated into the normal NumPy hierarchy and won't show "
"up with the above function."
msgstr ""

