# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2008-2014, the pandas development team
# This file is distributed under the same license as the pandas package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: pandas 0.24.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-04-11 11:49+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../user_guide/enhancingperf.rst:3
msgid "{{ header }}"
msgstr ""

#: ../../user_guide/enhancingperf.rst:7
msgid "Enhancing Performance"
msgstr ""

#: ../../user_guide/enhancingperf.rst:9
msgid ""
"In this part of the tutorial, we will investigate how to speed up certain"
" functions operating on pandas ``DataFrames`` using three different "
"techniques: Cython, Numba and :func:`pandas.eval`. We will see a speed "
"improvement of ~200 when we use Cython and Numba on a test function "
"operating row-wise on the ``DataFrame``. Using :func:`pandas.eval` we "
"will speed up a sum by an order of ~2."
msgstr ""

#: ../../user_guide/enhancingperf.rst:19
msgid "Cython (Writing C extensions for pandas)"
msgstr ""

#: ../../user_guide/enhancingperf.rst:21
msgid ""
"For many use cases writing pandas in pure Python and NumPy is sufficient."
" In some computationally heavy applications however, it can be possible "
"to achieve sizable speed-ups by offloading work to `cython "
"<http://cython.org/>`__."
msgstr ""

#: ../../user_guide/enhancingperf.rst:25
msgid ""
"This tutorial assumes you have refactored as much as possible in Python, "
"for example by trying to remove for-loops and making use of NumPy "
"vectorization. It's always worth optimising in Python first."
msgstr ""

#: ../../user_guide/enhancingperf.rst:29
msgid ""
"This tutorial walks through a \"typical\" process of cythonizing a slow "
"computation. We use an `example from the Cython documentation "
"<http://docs.cython.org/src/quickstart/cythonize.html>`__ but in the "
"context of pandas. Our final cythonized solution is around 100 times "
"faster than the pure Python solution."
msgstr ""

#: ../../user_guide/enhancingperf.rst:37
msgid "Pure python"
msgstr ""

#: ../../user_guide/enhancingperf.rst:39
msgid "We have a ``DataFrame`` to which we want to apply a function row-wise."
msgstr ""

#: ../../user_guide/enhancingperf.rst:49
msgid "Here's the function in pure Python:"
msgstr ""

#: ../../user_guide/enhancingperf.rst:63
msgid "We achieve our result by using ``apply`` (row-wise):"
msgstr ""

#: ../../user_guide/enhancingperf.rst:70
msgid ""
"But clearly this isn't fast enough for us. Let's take a look and see "
"where the time is spent during this operation (limited to the most time "
"consuming four calls) using the `prun ipython magic function "
"<http://ipython.org/ipython-"
"doc/stable/api/generated/IPython.core.magics.execution.html#IPython.core.magics.execution.ExecutionMagics.prun>`__:"
msgstr ""

#: ../../user_guide/enhancingperf.rst:78
msgid ""
"By far the majority of time is spend inside either ``integrate_f`` or "
"``f``, hence we'll concentrate our efforts cythonizing these two "
"functions."
msgstr ""

#: ../../user_guide/enhancingperf.rst:83
msgid ""
"In Python 2 replacing the ``range`` with its generator counterpart "
"(``xrange``) would mean the ``range`` line would vanish. In Python 3 "
"``range`` is already a generator."
msgstr ""

#: ../../user_guide/enhancingperf.rst:89
msgid "Plain Cython"
msgstr ""

#: ../../user_guide/enhancingperf.rst:91
msgid "First we're going to need to import the Cython magic function to ipython:"
msgstr ""

#: ../../user_guide/enhancingperf.rst:99
msgid ""
"Now, let's simply copy our functions over to Cython as is (the suffix is "
"here to distinguish between function versions):"
msgstr ""

#: ../../user_guide/enhancingperf.rst:117
msgid ""
"If you're having trouble pasting the above into your ipython, you may "
"need to be using bleeding edge ipython for paste to play well with cell "
"magics."
msgstr ""

#: ../../user_guide/enhancingperf.rst:126
msgid ""
"Already this has shaved a third off, not too bad for a simple copy and "
"paste."
msgstr ""

#: ../../user_guide/enhancingperf.rst:131
msgid "Adding type"
msgstr ""

#: ../../user_guide/enhancingperf.rst:133
msgid "We get another huge improvement simply by providing type information:"
msgstr ""

#: ../../user_guide/enhancingperf.rst:155
msgid ""
"Now, we're talking! It's now over ten times faster than the original "
"python implementation, and we haven't *really* modified the code. Let's "
"have another look at what's eating up time:"
msgstr ""

#: ../../user_guide/enhancingperf.rst:166
msgid "Using ndarray"
msgstr ""

#: ../../user_guide/enhancingperf.rst:168
msgid ""
"It's calling series... a lot! It's creating a Series from each row, and "
"get-ting from both the index and the series (three times for each row). "
"Function calls are expensive in Python, so maybe we could minimize these "
"by cythonizing the apply part."
msgstr ""

#: ../../user_guide/enhancingperf.rst:174
msgid ""
"We are now passing ndarrays into the Cython function, fortunately Cython "
"plays very nicely with NumPy."
msgstr ""

#: ../../user_guide/enhancingperf.rst:205
msgid ""
"The implementation is simple, it creates an array of zeros and loops over"
" the rows, applying our ``integrate_f_typed``, and putting this in the "
"zeros array."
msgstr ""

#: ../../user_guide/enhancingperf.rst:211
msgid ""
"You can **not pass** a ``Series`` directly as a ``ndarray`` typed "
"parameter to a Cython function. Instead pass the actual ``ndarray`` using"
" the :meth:`Series.to_numpy`. The reason is that the Cython definition is"
" specific to an ndarray and not the passed ``Series``."
msgstr ""

#: ../../user_guide/enhancingperf.rst:216
msgid "So, do not do this:"
msgstr ""

#: ../../user_guide/enhancingperf.rst:222
msgid "But rather, use :meth:`Series.to_numpy` to get the underlying ``ndarray``:"
msgstr ""

#: ../../user_guide/enhancingperf.rst:232
msgid ""
"Loops like this would be *extremely* slow in Python, but in Cython "
"looping over NumPy arrays is *fast*."
msgstr ""

#: ../../user_guide/enhancingperf.rst:240
msgid ""
"We've gotten another big improvement. Let's check again where the time is"
" spent:"
msgstr ""

#: ../../user_guide/enhancingperf.rst:246
msgid ""
"As one might expect, the majority of the time is now spent in "
"``apply_integrate_f``, so if we wanted to make anymore efficiencies we "
"must continue to concentrate our efforts here."
msgstr ""

#: ../../user_guide/enhancingperf.rst:253
msgid "More advanced techniques"
msgstr ""

#: ../../user_guide/enhancingperf.rst:255
msgid ""
"There is still hope for improvement. Here's an example of using some more"
" advanced Cython techniques:"
msgstr ""

#: ../../user_guide/enhancingperf.rst:292
msgid ""
"Even faster, with the caveat that a bug in our Cython code (an off-by-one"
" error, for example) might cause a segfault because memory access isn't "
"checked. For more about ``boundscheck`` and ``wraparound``, see the "
"Cython docs on `compiler directives "
"<http://cython.readthedocs.io/en/latest/src/reference/compilation.html?highlight=wraparound"
"#compiler-directives>`__."
msgstr ""

#: ../../user_guide/enhancingperf.rst:300
msgid "Using Numba"
msgstr ""

#: ../../user_guide/enhancingperf.rst:302
msgid ""
"A recent alternative to statically compiling Cython code, is to use a "
"*dynamic jit-compiler*, Numba."
msgstr ""

#: ../../user_guide/enhancingperf.rst:304
msgid ""
"Numba gives you the power to speed up your applications with high "
"performance functions written directly in Python. With a few annotations,"
" array-oriented and math-heavy Python code can be just-in-time compiled "
"to native machine instructions, similar in performance to C, C++ and "
"Fortran, without having to switch languages or Python interpreters."
msgstr ""

#: ../../user_guide/enhancingperf.rst:306
msgid ""
"Numba works by generating optimized machine code using the LLVM compiler "
"infrastructure at import time, runtime, or statically (using the included"
" pycc tool). Numba supports compilation of Python to run on either CPU or"
" GPU hardware, and is designed to integrate with the Python scientific "
"software stack."
msgstr ""

#: ../../user_guide/enhancingperf.rst:310
msgid ""
"You will need to install Numba. This is easy with ``conda``, by using: "
"``conda install numba``, see :ref:`installing using "
"miniconda<install.miniconda>`."
msgstr ""

#: ../../user_guide/enhancingperf.rst:314
msgid ""
"As of Numba version 0.20, pandas objects cannot be passed directly to "
"Numba-compiled functions. Instead, one must pass the NumPy array "
"underlying the pandas object to the Numba-compiled function as "
"demonstrated below."
msgstr ""

#: ../../user_guide/enhancingperf.rst:317
msgid "Jit"
msgstr ""

#: ../../user_guide/enhancingperf.rst:319
msgid ""
"We demonstrate how to use Numba to just-in-time compile our code. We "
"simply take the plain Python code from above and annotate with the "
"``@jit`` decorator."
msgstr ""

#: ../../user_guide/enhancingperf.rst:356
msgid ""
"Note that we directly pass NumPy arrays to the Numba function. "
"``compute_numba`` is just a wrapper that provides a nicer interface by "
"passing/returning pandas objects."
msgstr ""

#: ../../user_guide/enhancingperf.rst:364
msgid "In this example, using Numba was faster than Cython."
msgstr ""

#: ../../user_guide/enhancingperf.rst:367
msgid "Vectorize"
msgstr ""

#: ../../user_guide/enhancingperf.rst:369
msgid ""
"Numba can also be used to write vectorized functions that do not require "
"the user to explicitly loop over the observations of a vector; a "
"vectorized function will be applied to each row automatically. Consider "
"the following toy example of doubling each observation:"
msgstr ""

#: ../../user_guide/enhancingperf.rst:401
msgid "Caveats"
msgstr ""

#: ../../user_guide/enhancingperf.rst:405
msgid ""
"Numba will execute on any function, but can only accelerate certain "
"classes of functions."
msgstr ""

#: ../../user_guide/enhancingperf.rst:407
msgid ""
"Numba is best at accelerating functions that apply numerical functions to"
" NumPy arrays. When passed a function that only uses operations it knows "
"how to accelerate, it will execute in ``nopython`` mode."
msgstr ""

#: ../../user_guide/enhancingperf.rst:411
msgid ""
"If Numba is passed a function that includes something it doesn't know how"
" to work with -- a category that currently includes sets, lists, "
"dictionaries, or string functions -- it will revert to ``object mode``. "
"In ``object mode``, Numba will execute but your code will not speed up "
"significantly. If you would prefer that Numba throw an error if it cannot"
" compile a function in a way that speeds up your code, pass Numba the "
"argument ``nopython=True`` (e.g.  ``@numba.jit(nopython=True)``). For "
"more on troubleshooting Numba modes, see the `Numba troubleshooting page "
"<http://numba.pydata.org/numba-doc/latest/user/troubleshoot.html#the-"
"compiled-code-is-too-slow>`__."
msgstr ""

#: ../../user_guide/enhancingperf.rst:421
msgid "Read more in the `Numba docs <http://numba.pydata.org/>`__."
msgstr ""

#: ../../user_guide/enhancingperf.rst:426
msgid "Expression Evaluation via :func:`~pandas.eval`"
msgstr ""

#: ../../user_guide/enhancingperf.rst:428
msgid ""
"The top-level function :func:`pandas.eval` implements expression "
"evaluation of :class:`~pandas.Series` and :class:`~pandas.DataFrame` "
"objects."
msgstr ""

#: ../../user_guide/enhancingperf.rst:433
msgid ""
"To benefit from using :func:`~pandas.eval` you need to install "
"``numexpr``. See the :ref:`recommended dependencies section "
"<install.recommended_dependencies>` for more details."
msgstr ""

#: ../../user_guide/enhancingperf.rst:437
msgid ""
"The point of using :func:`~pandas.eval` for expression evaluation rather "
"than plain Python is two-fold: 1) large :class:`~pandas.DataFrame` "
"objects are evaluated more efficiently and 2) large arithmetic and "
"boolean expressions are evaluated all at once by the underlying engine "
"(by default ``numexpr`` is used for evaluation)."
msgstr ""

#: ../../user_guide/enhancingperf.rst:445
msgid ""
"You should not use :func:`~pandas.eval` for simple expressions or for "
"expressions involving small DataFrames. In fact, :func:`~pandas.eval` is "
"many orders of magnitude slower for smaller expressions/objects than "
"plain ol' Python. A good rule of thumb is to only use "
":func:`~pandas.eval` when you have a "
":class:`~pandas.core.frame.DataFrame` with more than 10,000 rows."
msgstr ""

#: ../../user_guide/enhancingperf.rst:453
msgid ""
":func:`~pandas.eval` supports all arithmetic expressions supported by the"
" engine in addition to some extensions available only in pandas."
msgstr ""

#: ../../user_guide/enhancingperf.rst:458
msgid ""
"The larger the frame and the larger the expression the more speedup you "
"will see from using :func:`~pandas.eval`."
msgstr ""

#: ../../user_guide/enhancingperf.rst:462
msgid "Supported Syntax"
msgstr ""

#: ../../user_guide/enhancingperf.rst:464
msgid "These operations are supported by :func:`pandas.eval`:"
msgstr ""

#: ../../user_guide/enhancingperf.rst:466
msgid ""
"Arithmetic operations except for the left shift (``<<``) and right shift "
"(``>>``) operators, e.g., ``df + 2 * pi / s ** 4 % 42 - "
"the_golden_ratio``"
msgstr ""

#: ../../user_guide/enhancingperf.rst:468
msgid ""
"Comparison operations, including chained comparisons, e.g., ``2 < df < "
"df2``"
msgstr ""

#: ../../user_guide/enhancingperf.rst:469
msgid "Boolean operations, e.g., ``df < df2 and df3 < df4 or not df_bool``"
msgstr ""

#: ../../user_guide/enhancingperf.rst:470
msgid "``list`` and ``tuple`` literals, e.g., ``[1, 2]`` or ``(1, 2)``"
msgstr ""

#: ../../user_guide/enhancingperf.rst:471
msgid "Attribute access, e.g., ``df.a``"
msgstr ""

#: ../../user_guide/enhancingperf.rst:472
msgid "Subscript expressions, e.g., ``df[0]``"
msgstr ""

#: ../../user_guide/enhancingperf.rst:473
msgid ""
"Simple variable evaluation, e.g., ``pd.eval('df')`` (this is not very "
"useful)"
msgstr ""

#: ../../user_guide/enhancingperf.rst:474
msgid ""
"Math functions: `sin`, `cos`, `exp`, `log`, `expm1`, `log1p`, `sqrt`, "
"`sinh`, `cosh`, `tanh`, `arcsin`, `arccos`, `arctan`, `arccosh`, "
"`arcsinh`, `arctanh`, `abs`, `arctan2` and `log10`."
msgstr ""

#: ../../user_guide/enhancingperf.rst:478
msgid "This Python syntax is **not** allowed:"
msgstr ""

#: ../../user_guide/enhancingperf.rst:480
msgid "Expressions"
msgstr ""

#: ../../user_guide/enhancingperf.rst:482
msgid "Function calls other than math functions."
msgstr ""

#: ../../user_guide/enhancingperf.rst:483
msgid "``is``/``is not`` operations"
msgstr ""

#: ../../user_guide/enhancingperf.rst:484
msgid "``if`` expressions"
msgstr ""

#: ../../user_guide/enhancingperf.rst:485
msgid "``lambda`` expressions"
msgstr ""

#: ../../user_guide/enhancingperf.rst:486
msgid "``list``/``set``/``dict`` comprehensions"
msgstr ""

#: ../../user_guide/enhancingperf.rst:487
msgid "Literal ``dict`` and ``set`` expressions"
msgstr ""

#: ../../user_guide/enhancingperf.rst:488
msgid "``yield`` expressions"
msgstr ""

#: ../../user_guide/enhancingperf.rst:489
msgid "Generator expressions"
msgstr ""

#: ../../user_guide/enhancingperf.rst:490
msgid "Boolean expressions consisting of only scalar values"
msgstr ""

#: ../../user_guide/enhancingperf.rst:492
msgid "Statements"
msgstr ""

#: ../../user_guide/enhancingperf.rst:494
msgid ""
"Neither `simple "
"<https://docs.python.org/3/reference/simple_stmts.html>`__ nor `compound "
"<https://docs.python.org/3/reference/compound_stmts.html>`__ statements "
"are allowed. This includes things like ``for``, ``while``, and ``if``."
msgstr ""

#: ../../user_guide/enhancingperf.rst:502
msgid ":func:`~pandas.eval` Examples"
msgstr ""

#: ../../user_guide/enhancingperf.rst:504
msgid ":func:`pandas.eval` works well with expressions containing large arrays."
msgstr ""

#: ../../user_guide/enhancingperf.rst:506
msgid "First let's create a few decent-sized arrays to play with:"
msgstr ""

#: ../../user_guide/enhancingperf.rst:514
msgid ""
"Now let's compare adding them together using plain ol' Python versus "
":func:`~pandas.eval`:"
msgstr ""

#: ../../user_guide/enhancingperf.rst:526
msgid "Now let's do the same thing but with comparisons:"
msgstr ""

#: ../../user_guide/enhancingperf.rst:537
msgid ":func:`~pandas.eval` also works with unaligned pandas objects:"
msgstr ""

#: ../../user_guide/enhancingperf.rst:550
msgid "Operations such as"
msgstr ""

#: ../../user_guide/enhancingperf.rst:558
msgid ""
"should be performed in Python. An exception will be raised if you try to "
"perform any boolean/bitwise operations with scalar operands that are not "
"of type ``bool`` or ``np.bool_``. Again, you should perform these kinds "
"of operations in plain Python."
msgstr ""

#: ../../user_guide/enhancingperf.rst:564
msgid "The ``DataFrame.eval`` method"
msgstr ""

#: ../../user_guide/enhancingperf.rst:566
msgid ""
"In addition to the top level :func:`pandas.eval` function you can also "
"evaluate an expression in the \"context\" of a "
":class:`~pandas.DataFrame`."
msgstr ""

#: ../../user_guide/enhancingperf.rst:587
msgid ""
"Any expression that is a valid :func:`pandas.eval` expression is also a "
"valid :meth:`DataFrame.eval` expression, with the added benefit that you "
"don't have to prefix the name of the :class:`~pandas.DataFrame` to the "
"column(s) you're interested in evaluating."
msgstr ""

#: ../../user_guide/enhancingperf.rst:592
msgid ""
"In addition, you can perform assignment of columns within an expression. "
"This allows for *formulaic evaluation*.  The assignment target can be a "
"new column name or an existing column name, and it must be a valid Python"
" identifier."
msgstr ""

#: ../../user_guide/enhancingperf.rst:599
msgid ""
"The ``inplace`` keyword determines whether this assignment will performed"
" on the original ``DataFrame`` or return a copy with the new column."
msgstr ""

#: ../../user_guide/enhancingperf.rst:604
msgid ""
"For backwards compatibility, ``inplace`` defaults to ``True`` if not "
"specified. This will change in a future version of pandas - if your code "
"depends on an inplace assignment you should update to explicitly set "
"``inplace=True``."
msgstr ""

#: ../../user_guide/enhancingperf.rst:617
msgid ""
"When ``inplace`` is set to ``False``, a copy of the ``DataFrame`` with "
"the new or modified columns is returned and the original frame is "
"unchanged."
msgstr ""

#: ../../user_guide/enhancingperf.rst:628
msgid ""
"As a convenience, multiple assignments can be performed by using a multi-"
"line string."
msgstr ""

#: ../../user_guide/enhancingperf.rst:638
msgid "The equivalent in standard Python would be"
msgstr ""

#: ../../user_guide/enhancingperf.rst:650
msgid ""
"The ``query`` method gained the ``inplace`` keyword which determines "
"whether the query modifies the original frame."
msgstr ""

#: ../../user_guide/enhancingperf.rst:662
msgid ""
"Unlike with ``eval``, the default value for ``inplace`` for ``query`` is "
"``False``.  This is consistent with prior versions of pandas."
msgstr ""

#: ../../user_guide/enhancingperf.rst:666
msgid "Local Variables"
msgstr ""

#: ../../user_guide/enhancingperf.rst:668
msgid ""
"You must *explicitly reference* any local variable that you want to use "
"in an expression by placing the ``@`` character in front of the name. For"
" example,"
msgstr ""

#: ../../user_guide/enhancingperf.rst:678
msgid ""
"If you don't prefix the local variable with ``@``, pandas will raise an "
"exception telling you the variable is undefined."
msgstr ""

#: ../../user_guide/enhancingperf.rst:681
msgid ""
"When using :meth:`DataFrame.eval` and :meth:`DataFrame.query`, this "
"allows you to have a local variable and a :class:`~pandas.DataFrame` "
"column with the same name in an expression."
msgstr ""

#: ../../user_guide/enhancingperf.rst:692
msgid ""
"With :func:`pandas.eval` you cannot use the ``@`` prefix *at all*, "
"because it isn't defined in that context. ``pandas`` will let you know "
"this if you try to use ``@`` in a top-level call to :func:`pandas.eval`. "
"For example,"
msgstr ""

#: ../../user_guide/enhancingperf.rst:702
msgid ""
"In this case, you should simply refer to the variables like you would in "
"standard Python."
msgstr ""

#: ../../user_guide/enhancingperf.rst:711
msgid ":func:`pandas.eval` Parsers"
msgstr ""

#: ../../user_guide/enhancingperf.rst:713
msgid ""
"There are two different parsers and two different engines you can use as "
"the backend."
msgstr ""

#: ../../user_guide/enhancingperf.rst:716
msgid ""
"The default ``'pandas'`` parser allows a more intuitive syntax for "
"expressing query-like operations (comparisons, conjunctions and "
"disjunctions). In particular, the precedence of the ``&`` and ``|`` "
"operators is made equal to the precedence of the corresponding boolean "
"operations ``and`` and ``or``."
msgstr ""

#: ../../user_guide/enhancingperf.rst:721
msgid ""
"For example, the above conjunction can be written without parentheses. "
"Alternatively, you can use the ``'python'`` parser to enforce strict "
"Python semantics."
msgstr ""

#: ../../user_guide/enhancingperf.rst:734
msgid ""
"The same expression can be \"anded\" together with the word "
":keyword:`and` as well:"
msgstr ""

#: ../../user_guide/enhancingperf.rst:746
msgid ""
"The ``and`` and ``or`` operators here have the same precedence that they "
"would in vanilla Python."
msgstr ""

#: ../../user_guide/enhancingperf.rst:751
msgid ":func:`pandas.eval` Backends"
msgstr ""

#: ../../user_guide/enhancingperf.rst:753
msgid ""
"There's also the option to make :func:`~pandas.eval` operate identical to"
" plain ol' Python."
msgstr ""

#: ../../user_guide/enhancingperf.rst:758
msgid ""
"Using the ``'python'`` engine is generally *not* useful, except for "
"testing other evaluation engines against it. You will achieve **no** "
"performance benefits using :func:`~pandas.eval` with ``engine='python'`` "
"and in fact may incur a performance hit."
msgstr ""

#: ../../user_guide/enhancingperf.rst:763
msgid ""
"You can see this by using :func:`pandas.eval` with the ``'python'`` "
"engine. It is a bit slower (not by much) than evaluating the same "
"expression in Python"
msgstr ""

#: ../../user_guide/enhancingperf.rst:776
msgid ":func:`pandas.eval` Performance"
msgstr ""

#: ../../user_guide/enhancingperf.rst:778
msgid ""
":func:`~pandas.eval` is intended to speed up certain kinds of operations."
" In particular, those operations involving complex expressions with large"
" :class:`~pandas.DataFrame`/:class:`~pandas.Series` objects should see a "
"significant performance benefit.  Here is a plot showing the running time"
" of :func:`pandas.eval` as function of the size of the frame involved in "
"the computation. The two lines are two different engines."
msgstr ""

#: ../../user_guide/enhancingperf.rst:791
msgid ""
"Operations with smallish objects (around 15k-20k rows) are faster using "
"plain Python:"
msgstr ""

#: ../../user_guide/enhancingperf.rst:797
msgid ""
"This plot was created using a ``DataFrame`` with 3 columns each "
"containing floating point values generated using "
"``numpy.random.randn()``."
msgstr ""

#: ../../user_guide/enhancingperf.rst:801
msgid "Technical Minutia Regarding Expression Evaluation"
msgstr ""

#: ../../user_guide/enhancingperf.rst:803
msgid ""
"Expressions that would result in an object dtype or involve datetime "
"operations (because of ``NaT``) must be evaluated in Python space. The "
"main reason for this behavior is to maintain backwards compatibility with"
" versions of NumPy < 1.7. In those versions of NumPy a call to "
"``ndarray.astype(str)`` will truncate any strings that are more than 60 "
"characters in length. Second, we can't pass ``object`` arrays to "
"``numexpr`` thus string comparisons must be evaluated in Python space."
msgstr ""

#: ../../user_guide/enhancingperf.rst:811
msgid ""
"The upshot is that this *only* applies to object-dtype expressions. So, "
"if you have an expression--for example"
msgstr ""

#: ../../user_guide/enhancingperf.rst:821
msgid ""
"the numeric part of the comparison (``nums == 1``) will be evaluated by "
"``numexpr``."
msgstr ""

#: ../../user_guide/enhancingperf.rst:824
msgid ""
"In general, :meth:`DataFrame.query`/:func:`pandas.eval` will evaluate the"
" subexpressions that *can* be evaluated by ``numexpr`` and those that "
"must be evaluated in Python space transparently to the user. This is done"
" by inferring the result type of an expression from its arguments and "
"operators."
msgstr ""

