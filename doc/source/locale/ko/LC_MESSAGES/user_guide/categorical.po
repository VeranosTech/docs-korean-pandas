# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2008-2014, the pandas development team
# This file is distributed under the same license as the pandas package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: pandas 0.24.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-04-11 11:49+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../user_guide/categorical.rst:3
msgid "{{ header }}"
msgstr ""

#: ../../user_guide/categorical.rst:7
msgid "Categorical Data"
msgstr ""

#: ../../user_guide/categorical.rst:9
msgid ""
"This is an introduction to pandas categorical data type, including a "
"short comparison with R's ``factor``."
msgstr ""

#: ../../user_guide/categorical.rst:12
msgid ""
"`Categoricals` are a pandas data type corresponding to categorical "
"variables in statistics. A categorical variable takes on a limited, and "
"usually fixed, number of possible values (`categories`; `levels` in R). "
"Examples are gender, social class, blood type, country affiliation, "
"observation time or rating via Likert scales."
msgstr ""

#: ../../user_guide/categorical.rst:18
msgid ""
"In contrast to statistical categorical variables, categorical data might "
"have an order (e.g. 'strongly agree' vs 'agree' or 'first observation' "
"vs. 'second observation'), but numerical operations (additions, "
"divisions, ...) are not possible."
msgstr ""

#: ../../user_guide/categorical.rst:22
msgid ""
"All values of categorical data are either in `categories` or `np.nan`. "
"Order is defined by the order of `categories`, not lexical order of the "
"values. Internally, the data structure consists of a `categories` array "
"and an integer array of `codes` which point to the real value in the "
"`categories` array."
msgstr ""

#: ../../user_guide/categorical.rst:27
msgid "The categorical data type is useful in the following cases:"
msgstr ""

#: ../../user_guide/categorical.rst:29
msgid ""
"A string variable consisting of only a few different values. Converting "
"such a string variable to a categorical variable will save some memory, "
"see :ref:`here <categorical.memory>`."
msgstr ""

#: ../../user_guide/categorical.rst:31
msgid ""
"The lexical order of a variable is not the same as the logical order "
"(\"one\", \"two\", \"three\"). By converting to a categorical and "
"specifying an order on the categories, sorting and min/max will use the "
"logical order instead of the lexical order, see :ref:`here "
"<categorical.sort>`."
msgstr ""

#: ../../user_guide/categorical.rst:34
msgid ""
"As a signal to other Python libraries that this column should be treated "
"as a categorical variable (e.g. to use suitable statistical methods or "
"plot types)."
msgstr ""

#: ../../user_guide/categorical.rst:37
msgid "See also the :ref:`API docs on categoricals<api.arrays.categorical>`."
msgstr ""

#: ../../user_guide/categorical.rst:42
msgid "Object Creation"
msgstr ""

#: ../../user_guide/categorical.rst:45
msgid "Series Creation"
msgstr ""

#: ../../user_guide/categorical.rst:47
msgid ""
"Categorical ``Series`` or columns in a ``DataFrame`` can be created in "
"several ways:"
msgstr ""

#: ../../user_guide/categorical.rst:49
msgid "By specifying ``dtype=\"category\"`` when constructing a ``Series``:"
msgstr ""

#: ../../user_guide/categorical.rst:56
msgid "By converting an existing ``Series`` or column to a ``category`` dtype:"
msgstr ""

#: ../../user_guide/categorical.rst:64
msgid ""
"By using special functions, such as :func:`~pandas.cut`, which groups "
"data into discrete bins. See the :ref:`example on tiling "
"<reshaping.tile.cut>` in the docs."
msgstr ""

#: ../../user_guide/categorical.rst:75
msgid ""
"By passing a :class:`pandas.Categorical` object to a ``Series`` or "
"assigning it to a ``DataFrame``."
msgstr ""

#: ../../user_guide/categorical.rst:87
msgid "Categorical data has a specific ``category`` :ref:`dtype <basics.dtypes>`:"
msgstr ""

#: ../../user_guide/categorical.rst:94
msgid "DataFrame Creation"
msgstr ""

#: ../../user_guide/categorical.rst:96
msgid ""
"Similar to the previous section where a single column was converted to "
"categorical, all columns in a ``DataFrame`` can be batch converted to "
"categorical either during or after construction."
msgstr ""

#: ../../user_guide/categorical.rst:99
msgid ""
"This can be done during construction by specifying ``dtype=\"category\"``"
" in the ``DataFrame`` constructor:"
msgstr ""

#: ../../user_guide/categorical.rst:106
msgid ""
"Note that the categories present in each column differ; the conversion is"
" done column by column, so only labels present in a given column are "
"categories:"
msgstr ""

#: ../../user_guide/categorical.rst:117
msgid ""
"Analogously, all columns in an existing ``DataFrame`` can be batch "
"converted using :meth:`DataFrame.astype`:"
msgstr ""

#: ../../user_guide/categorical.rst:125
msgid "This conversion is likewise done column by column:"
msgstr ""

#: ../../user_guide/categorical.rst:134
msgid "Controlling Behavior"
msgstr ""

#: ../../user_guide/categorical.rst:136
msgid ""
"In the examples above where we passed ``dtype='category'``, we used the "
"default behavior:"
msgstr ""

#: ../../user_guide/categorical.rst:139
msgid "Categories are inferred from the data."
msgstr ""

#: ../../user_guide/categorical.rst:140
msgid "Categories are unordered."
msgstr ""

#: ../../user_guide/categorical.rst:142
msgid ""
"To control those behaviors, instead of passing ``'category'``, use an "
"instance of :class:`~pandas.api.types.CategoricalDtype`."
msgstr ""

#: ../../user_guide/categorical.rst:154
msgid ""
"Similarly, a ``CategoricalDtype`` can be used with a ``DataFrame`` to "
"ensure that categories are consistent among all columns."
msgstr ""

#: ../../user_guide/categorical.rst:169
msgid ""
"To perform table-wise conversion, where all labels in the entire "
"``DataFrame`` are used as categories for each column, the ``categories`` "
"parameter can be determined programmatically by ``categories = "
"pd.unique(df.to_numpy().ravel())``."
msgstr ""

#: ../../user_guide/categorical.rst:173
msgid ""
"If you already have ``codes`` and ``categories``, you can use the "
":func:`~pandas.Categorical.from_codes` constructor to save the factorize "
"step during normal constructor mode:"
msgstr ""

#: ../../user_guide/categorical.rst:185
msgid "Regaining Original Data"
msgstr ""

#: ../../user_guide/categorical.rst:187
msgid ""
"To get back to the original ``Series`` or NumPy array, use "
"``Series.astype(original_dtype)`` or ``np.asarray(categorical)``:"
msgstr ""

#: ../../user_guide/categorical.rst:201
msgid ""
"In contrast to R's `factor` function, categorical data is not converting "
"input values to strings; categories will end up the same data type as the"
" original values."
msgstr ""

#: ../../user_guide/categorical.rst:206
msgid ""
"In contrast to R's `factor` function, there is currently no way to "
"assign/change labels at creation time. Use `categories` to change the "
"categories after creation time."
msgstr ""

#: ../../user_guide/categorical.rst:212
msgid "CategoricalDtype"
msgstr ""

#: ../../user_guide/categorical.rst:216
msgid "A categorical's type is fully described by"
msgstr ""

#: ../../user_guide/categorical.rst:218
msgid "``categories``: a sequence of unique values and no missing values"
msgstr ""

#: ../../user_guide/categorical.rst:219
msgid "``ordered``: a boolean"
msgstr ""

#: ../../user_guide/categorical.rst:221
msgid ""
"This information can be stored in a "
":class:`~pandas.api.types.CategoricalDtype`. The ``categories`` argument "
"is optional, which implies that the actual categories should be inferred "
"from whatever is present in the data when the :class:`pandas.Categorical`"
" is created. The categories are assumed to be unordered by default."
msgstr ""

#: ../../user_guide/categorical.rst:234
msgid ""
"A :class:`~pandas.api.types.CategoricalDtype` can be used in any place "
"pandas expects a `dtype`. For example :func:`pandas.read_csv`, "
":func:`pandas.DataFrame.astype`, or in the ``Series`` constructor."
msgstr ""

#: ../../user_guide/categorical.rst:240
msgid ""
"As a convenience, you can use the string ``'category'`` in place of a "
":class:`~pandas.api.types.CategoricalDtype` when you want the default "
"behavior of the categories being unordered, and equal to the set values "
"present in the array. In other words, ``dtype='category'`` is equivalent "
"to ``dtype=CategoricalDtype()``."
msgstr ""

#: ../../user_guide/categorical.rst:247
msgid "Equality Semantics"
msgstr ""

#: ../../user_guide/categorical.rst:249
msgid ""
"Two instances of :class:`~pandas.api.types.CategoricalDtype` compare "
"equal whenever they have the same categories and order. When comparing "
"two unordered categoricals, the order of the ``categories`` is not "
"considered."
msgstr ""

#: ../../user_guide/categorical.rst:263
msgid ""
"All instances of ``CategoricalDtype`` compare equal to the string "
"``'category'``."
msgstr ""

#: ../../user_guide/categorical.rst:271
msgid ""
"Since ``dtype='category'`` is essentially ``CategoricalDtype(None, "
"False)``, and since all instances ``CategoricalDtype`` compare equal to "
"``'category'``, all instances of ``CategoricalDtype`` compare equal to a "
"``CategoricalDtype(None, False)``, regardless of ``categories`` or "
"``ordered``."
msgstr ""

#: ../../user_guide/categorical.rst:278
msgid "Description"
msgstr ""

#: ../../user_guide/categorical.rst:280
msgid ""
"Using :meth:`~DataFrame.describe` on categorical data will produce "
"similar output to a ``Series`` or ``DataFrame`` of type ``string``."
msgstr ""

#: ../../user_guide/categorical.rst:293
msgid "Working with categories"
msgstr ""

#: ../../user_guide/categorical.rst:295
msgid ""
"Categorical data has a `categories` and a `ordered` property, which list "
"their possible values and whether the ordering matters or not. These "
"properties are exposed as ``s.cat.categories`` and ``s.cat.ordered``. If "
"you don't manually specify categories and ordering, they are inferred "
"from the passed arguments."
msgstr ""

#: ../../user_guide/categorical.rst:306
msgid "It's also possible to pass in the categories in a specific order:"
msgstr ""

#: ../../user_guide/categorical.rst:317
msgid ""
"New categorical data are **not** automatically ordered. You must "
"explicitly pass ``ordered=True`` to indicate an ordered ``Categorical``."
msgstr ""

#: ../../user_guide/categorical.rst:323
msgid ""
"The result of :meth:`~Series.unique` is not always the same as "
"``Series.cat.categories``, because ``Series.unique()`` has a couple of "
"guarantees, namely that it returns categories in the order of appearance,"
" and it only includes values that are actually present."
msgstr ""

#: ../../user_guide/categorical.rst:339
msgid "Renaming categories"
msgstr ""

#: ../../user_guide/categorical.rst:341
msgid ""
"Renaming categories is done by assigning new values to the "
"``Series.cat.categories`` property or by using the "
":meth:`~pandas.Categorical.rename_categories` method:"
msgstr ""

#: ../../user_guide/categorical.rst:360
msgid ""
"In contrast to R's `factor`, categorical data can have categories of "
"other types than string."
msgstr ""

#: ../../user_guide/categorical.rst:364
msgid ""
"Be aware that assigning new categories is an inplace operation, while "
"most other operations under ``Series.cat`` per default return a new "
"``Series`` of dtype `category`."
msgstr ""

#: ../../user_guide/categorical.rst:367
msgid "Categories must be unique or a `ValueError` is raised:"
msgstr ""

#: ../../user_guide/categorical.rst:376
msgid "Categories must also not be ``NaN`` or a `ValueError` is raised:"
msgstr ""

#: ../../user_guide/categorical.rst:386
msgid "Appending new categories"
msgstr ""

#: ../../user_guide/categorical.rst:388
msgid ""
"Appending categories can be done by using the "
":meth:`~pandas.Categorical.add_categories` method:"
msgstr ""

#: ../../user_guide/categorical.rst:398
msgid "Removing categories"
msgstr ""

#: ../../user_guide/categorical.rst:400
msgid ""
"Removing categories can be done by using the "
":meth:`~pandas.Categorical.remove_categories` method. Values which are "
"removed are replaced by ``np.nan``.:"
msgstr ""

#: ../../user_guide/categorical.rst:410
msgid "Removing unused categories"
msgstr ""

#: ../../user_guide/categorical.rst:412
msgid "Removing unused categories can also be done:"
msgstr ""

#: ../../user_guide/categorical.rst:422
msgid "Setting categories"
msgstr ""

#: ../../user_guide/categorical.rst:424
msgid ""
"If you want to do remove and add new categories in one step (which has "
"some speed advantage), or simply set the categories to a predefined "
"scale, use :meth:`~pandas.Categorical.set_categories`."
msgstr ""

#: ../../user_guide/categorical.rst:437
msgid ""
"Be aware that :func:`Categorical.set_categories` cannot know whether some"
" category is omitted intentionally or because it is misspelled or (under "
"Python3) due to a type difference (e.g., NumPy S1 dtype and Python "
"strings). This can result in surprising behaviour!"
msgstr ""

#: ../../user_guide/categorical.rst:442
msgid "Sorting and Order"
msgstr ""

#: ../../user_guide/categorical.rst:446
msgid ""
"If categorical data is ordered (``s.cat.ordered == True``), then the "
"order of the categories has a meaning and certain operations are "
"possible. If the categorical is unordered, ``.min()/.max()`` will raise a"
" ``TypeError``."
msgstr ""

#: ../../user_guide/categorical.rst:460
msgid ""
"You can set categorical data to be ordered by using ``as_ordered()`` or "
"unordered by using ``as_unordered()``. These will by default return a "
"*new* object."
msgstr ""

#: ../../user_guide/categorical.rst:468
msgid ""
"Sorting will use the order defined by categories, not any lexical order "
"present on the data type. This is even true for strings and numeric data:"
msgstr ""

#: ../../user_guide/categorical.rst:482
msgid "Reordering"
msgstr ""

#: ../../user_guide/categorical.rst:484
msgid ""
"Reordering the categories is possible via the "
":meth:`Categorical.reorder_categories` and the "
":meth:`Categorical.set_categories` methods. For "
":meth:`Categorical.reorder_categories`, all old categories must be "
"included in the new categories and no new categories are allowed. This "
"will necessarily make the sort order the same as the categories order."
msgstr ""

#: ../../user_guide/categorical.rst:500
msgid ""
"Note the difference between assigning new categories and reordering the "
"categories: the first renames categories and therefore the individual "
"values in the ``Series``, but if the first position was sorted last, the "
"renamed value will still be sorted last. Reordering means that the way "
"values are sorted is different afterwards, but not that individual values"
" in the ``Series`` are changed."
msgstr ""

#: ../../user_guide/categorical.rst:508
msgid ""
"If the ``Categorical`` is not ordered, :meth:`Series.min` and "
":meth:`Series.max` will raise ``TypeError``. Numeric operations like "
"``+``, ``-``, ``*``, ``/`` and operations based on them (e.g. "
":meth:`Series.median`, which would need to compute the mean between two "
"values if the length of an array is even) do not work and raise a "
"``TypeError``."
msgstr ""

#: ../../user_guide/categorical.rst:514
msgid "Multi Column Sorting"
msgstr ""

#: ../../user_guide/categorical.rst:516
msgid ""
"A categorical dtyped column will participate in a multi-column sort in a "
"similar manner to other columns. The ordering of the categorical is "
"determined by the ``categories`` of that column."
msgstr ""

#: ../../user_guide/categorical.rst:527
msgid "Reordering the ``categories`` changes a future sort."
msgstr ""

#: ../../user_guide/categorical.rst:535
msgid "Comparisons"
msgstr ""

#: ../../user_guide/categorical.rst:537
msgid "Comparing categorical data with other objects is possible in three cases:"
msgstr ""

#: ../../user_guide/categorical.rst:539
msgid ""
"Comparing equality (``==`` and ``!=``) to a list-like object (list, "
"Series, array, ...) of the same length as the categorical data."
msgstr ""

#: ../../user_guide/categorical.rst:541
msgid ""
"All comparisons (``==``, ``!=``, ``>``, ``>=``, ``<``, and ``<=``) of "
"categorical data to another categorical Series, when ``ordered==True`` "
"and the `categories` are the same."
msgstr ""

#: ../../user_guide/categorical.rst:543
msgid "All comparisons of a categorical data to a scalar."
msgstr ""

#: ../../user_guide/categorical.rst:545
msgid ""
"All other comparisons, especially \"non-equality\" comparisons of two "
"categoricals with different categories or a categorical with any list-"
"like object, will raise a ``TypeError``."
msgstr ""

#: ../../user_guide/categorical.rst:550
msgid ""
"Any \"non-equality\" comparisons of categorical data with a ``Series``, "
"``np.array``, ``list`` or categorical data with different categories or "
"ordering will raise a ``TypeError`` because custom categories ordering "
"could be interpreted in two ways: one with taking into account the "
"ordering and one without."
msgstr ""

#: ../../user_guide/categorical.rst:571
msgid ""
"Comparing to a categorical with the same categories and ordering or to a "
"scalar works:"
msgstr ""

#: ../../user_guide/categorical.rst:578
msgid ""
"Equality comparisons work with any list-like object of same length and "
"scalars:"
msgstr ""

#: ../../user_guide/categorical.rst:586
msgid "This doesn't work because the categories are not the same:"
msgstr ""

#: ../../user_guide/categorical.rst:595
msgid ""
"If you want to do a \"non-equality\" comparison of a categorical series "
"with a list-like object which is not categorical data, you need to be "
"explicit and convert the categorical data back to the original values:"
msgstr ""

#: ../../user_guide/categorical.rst:610
msgid ""
"When you compare two unordered categoricals with the same categories, the"
" order is not considered:"
msgstr ""

#: ../../user_guide/categorical.rst:619
msgid "Operations"
msgstr ""

#: ../../user_guide/categorical.rst:621
msgid ""
"Apart from :meth:`Series.min`, :meth:`Series.max` and "
":meth:`Series.mode`, the following operations are possible with "
"categorical data:"
msgstr ""

#: ../../user_guide/categorical.rst:624
msgid ""
"``Series`` methods like :meth:`Series.value_counts` will use all "
"categories, even if some categories are not present in the data:"
msgstr ""

#: ../../user_guide/categorical.rst:633
msgid "Groupby will also show \"unused\" categories:"
msgstr ""

#: ../../user_guide/categorical.rst:649
msgid "Pivot tables:"
msgstr ""

#: ../../user_guide/categorical.rst:660
msgid "Data munging"
msgstr ""

#: ../../user_guide/categorical.rst:662
msgid ""
"The optimized pandas data access methods  ``.loc``, ``.iloc``, ``.at``, "
"and ``.iat``, work as normal. The only difference is the return type (for"
" getting) and that only values already in `categories` can be assigned."
msgstr ""

#: ../../user_guide/categorical.rst:667
msgid "Getting"
msgstr ""

#: ../../user_guide/categorical.rst:669
msgid ""
"If the slicing operation returns either a ``DataFrame`` or a column of "
"type ``Series``, the ``category`` dtype is preserved."
msgstr ""

#: ../../user_guide/categorical.rst:684
msgid ""
"An example where the category type is not preserved is if you take one "
"single row: the resulting ``Series`` is of dtype ``object``:"
msgstr ""

#: ../../user_guide/categorical.rst:692
msgid ""
"Returning a single item from categorical data will also return the value,"
" not a categorical of length \"1\"."
msgstr ""

#: ../../user_guide/categorical.rst:702
msgid ""
"The is in contrast to R's `factor` function, where "
"``factor(c(1,2,3))[1]`` returns a single value `factor`."
msgstr ""

#: ../../user_guide/categorical.rst:705
msgid ""
"To get a single value ``Series`` of type ``category``, you pass in a list"
" with a single value:"
msgstr ""

#: ../../user_guide/categorical.rst:713
msgid "String and datetime accessors"
msgstr ""

#: ../../user_guide/categorical.rst:715
msgid ""
"The accessors  ``.dt`` and ``.str`` will work if the ``s.cat.categories``"
" are of an appropriate type:"
msgstr ""

#: ../../user_guide/categorical.rst:733
msgid ""
"The returned ``Series`` (or ``DataFrame``) is of the same type as if you "
"used the ``.str.<method>`` / ``.dt.<method>`` on a ``Series`` of that "
"type (and not of type ``category``!)."
msgstr ""

#: ../../user_guide/categorical.rst:737
msgid ""
"That means, that the returned values from methods and properties on the "
"accessors of a ``Series`` and the returned values from methods and "
"properties on the accessors of this ``Series`` transformed to one of type"
" `category` will be equal:"
msgstr ""

#: ../../user_guide/categorical.rst:750
msgid ""
"The work is done on the ``categories`` and then a new ``Series`` is "
"constructed. This has some performance implication if you have a "
"``Series`` of type string, where lots of elements are repeated (i.e. the "
"number of unique elements in the ``Series`` is a lot smaller than the "
"length of the ``Series``). In this case it can be faster to convert the "
"original ``Series`` to one of type ``category`` and use ``.str.<method>``"
" or ``.dt.<property>`` on that."
msgstr ""

#: ../../user_guide/categorical.rst:757
msgid "Setting"
msgstr ""

#: ../../user_guide/categorical.rst:759
msgid ""
"Setting values in a categorical column (or ``Series``) works as long as "
"the value is included in the `categories`:"
msgstr ""

#: ../../user_guide/categorical.rst:777
msgid ""
"Setting values by assigning categorical data will also check that the "
"`categories` match:"
msgstr ""

#: ../../user_guide/categorical.rst:789
msgid ""
"Assigning a ``Categorical`` to parts of a column of other types will use "
"the values:"
msgstr ""

#: ../../user_guide/categorical.rst:802
msgid "Merging"
msgstr ""

#: ../../user_guide/categorical.rst:804
msgid ""
"You can concat two ``DataFrames`` containing categorical data together, "
"but the categories of these categoricals need to be the same:"
msgstr ""

#: ../../user_guide/categorical.rst:816
msgid ""
"In this case the categories are not the same, and therefore an error is "
"raised:"
msgstr ""

#: ../../user_guide/categorical.rst:827
msgid "The same applies to ``df.append(df_different)``."
msgstr ""

#: ../../user_guide/categorical.rst:829
msgid ""
"See also the section on :ref:`merge dtypes<merging.dtypes>` for notes "
"about preserving merge dtypes and performance."
msgstr ""

#: ../../user_guide/categorical.rst:835
msgid "Unioning"
msgstr ""

#: ../../user_guide/categorical.rst:839
msgid ""
"If you want to combine categoricals that do not necessarily have the same"
" categories, the :func:`~pandas.api.types.union_categoricals` function "
"will combine a list-like of categoricals. The new categories will be the "
"union of the categories being combined."
msgstr ""

#: ../../user_guide/categorical.rst:851
msgid ""
"By default, the resulting categories will be ordered as they appear in "
"the data. If you want the categories to be lexsorted, use "
"``sort_categories=True`` argument."
msgstr ""

#: ../../user_guide/categorical.rst:859
msgid ""
"``union_categoricals`` also works with the \"easy\" case of combining two"
" categoricals of the same categories and order information (e.g. what you"
" could also ``append`` for)."
msgstr ""

#: ../../user_guide/categorical.rst:869
msgid ""
"The below raises ``TypeError`` because the categories are ordered and not"
" identical."
msgstr ""

#: ../../user_guide/categorical.rst:881
msgid ""
"Ordered categoricals with different categories or orderings can be "
"combined by using the ``ignore_ordered=True`` argument."
msgstr ""

#: ../../user_guide/categorical.rst:890
msgid ""
":func:`~pandas.api.types.union_categoricals` also works with a "
"``CategoricalIndex``, or ``Series`` containing categorical data, but note"
" that the resulting array will always be a plain ``Categorical``:"
msgstr ""

#: ../../user_guide/categorical.rst:902
msgid ""
"``union_categoricals`` may recode the integer codes for categories when "
"combining categoricals.  This is likely what you want, but if you are "
"relying on the exact numbering of the categories, be aware."
msgstr ""

#: ../../user_guide/categorical.rst:928
msgid "Concatenation"
msgstr ""

#: ../../user_guide/categorical.rst:930
msgid ""
"This section describes concatenations specific to ``category`` dtype. See"
" :ref:`Concatenating objects<merging.concat>` for general description."
msgstr ""

#: ../../user_guide/categorical.rst:932
msgid ""
"By default, ``Series`` or ``DataFrame`` concatenation which contains the "
"same categories results in ``category`` dtype, otherwise results in "
"``object`` dtype. Use ``.astype`` or ``union_categoricals`` to get "
"``category`` result."
msgstr ""

#: ../../user_guide/categorical.rst:951
msgid ""
"Following table summarizes the results of ``Categoricals`` related "
"concatenations."
msgstr ""

#: ../../user_guide/categorical.rst:954
msgid "arg1"
msgstr ""

#: ../../user_guide/categorical.rst:954
msgid "arg2"
msgstr ""

#: ../../user_guide/categorical.rst:954
msgid "result"
msgstr ""

#: ../../user_guide/categorical.rst:956 ../../user_guide/categorical.rst:958
#: ../../user_guide/categorical.rst:960 ../../user_guide/categorical.rst:962
msgid "category"
msgstr ""

#: ../../user_guide/categorical.rst:956
msgid "category (identical categories)"
msgstr ""

#: ../../user_guide/categorical.rst:958
msgid "category (different categories, both not ordered)"
msgstr ""

#: ../../user_guide/categorical.rst:958 ../../user_guide/categorical.rst:960
#: ../../user_guide/categorical.rst:962
msgid "object (dtype is inferred)"
msgstr ""

#: ../../user_guide/categorical.rst:960
msgid "category (different categories, either one is ordered)"
msgstr ""

#: ../../user_guide/categorical.rst:962
msgid "not category"
msgstr ""

#: ../../user_guide/categorical.rst:967
msgid "Getting Data In/Out"
msgstr ""

#: ../../user_guide/categorical.rst:969
msgid ""
"You can write data that contains ``category`` dtypes to a ``HDFStore``. "
"See :ref:`here <io.hdf5-categorical>` for an example and caveats."
msgstr ""

#: ../../user_guide/categorical.rst:972
msgid ""
"It is also possible to write data to and reading data from *Stata* format"
" files. See :ref:`here <io.stata-categorical>` for an example and "
"caveats."
msgstr ""

#: ../../user_guide/categorical.rst:975
msgid ""
"Writing to a CSV file will convert the data, effectively removing any "
"information about the categorical (categories and ordering). So if you "
"read back the CSV file you have to convert the relevant columns back to "
"`category` and assign the right categories and categories ordering."
msgstr ""

#: ../../user_guide/categorical.rst:1001
msgid "The same holds for writing to a SQL database with ``to_sql``."
msgstr ""

#: ../../user_guide/categorical.rst:1004
msgid "Missing Data"
msgstr ""

#: ../../user_guide/categorical.rst:1006
msgid ""
"pandas primarily uses the value `np.nan` to represent missing data. It is"
" by default not included in computations. See the :ref:`Missing Data "
"section <missing_data>`."
msgstr ""

#: ../../user_guide/categorical.rst:1010
msgid ""
"Missing values should **not** be included in the Categorical's "
"``categories``, only in the ``values``. Instead, it is understood that "
"NaN is different, and is always a possibility. When working with the "
"Categorical's ``codes``, missing values will always have a code of "
"``-1``."
msgstr ""

#: ../../user_guide/categorical.rst:1024
msgid ""
"Methods for working with missing data, e.g. :meth:`~Series.isna`, "
":meth:`~Series.fillna`, :meth:`~Series.dropna`, all work normally:"
msgstr ""

#: ../../user_guide/categorical.rst:1035
msgid "Differences to R's `factor`"
msgstr ""

#: ../../user_guide/categorical.rst:1037
msgid "The following differences to R's factor functions can be observed:"
msgstr ""

#: ../../user_guide/categorical.rst:1039
msgid "R's `levels` are named `categories`."
msgstr ""

#: ../../user_guide/categorical.rst:1040
msgid ""
"R's `levels` are always of type string, while `categories` in pandas can "
"be of any dtype."
msgstr ""

#: ../../user_guide/categorical.rst:1041
msgid ""
"It's not possible to specify labels at creation time. Use "
"``s.cat.rename_categories(new_labels)`` afterwards."
msgstr ""

#: ../../user_guide/categorical.rst:1043
msgid ""
"In contrast to R's `factor` function, using categorical data as the sole "
"input to create a new categorical series will *not* remove unused "
"categories but create a new categorical series which is equal to the "
"passed in one!"
msgstr ""

#: ../../user_guide/categorical.rst:1046
msgid ""
"R allows for missing values to be included in its `levels` (pandas' "
"`categories`). Pandas does not allow `NaN` categories, but missing values"
" can still be in the `values`."
msgstr ""

#: ../../user_guide/categorical.rst:1051
msgid "Gotchas"
msgstr ""

#: ../../user_guide/categorical.rst:1056
msgid "Memory Usage"
msgstr ""

#: ../../user_guide/categorical.rst:1060
msgid ""
"The memory usage of a ``Categorical`` is proportional to the number of "
"categories plus the length of the data. In contrast, an ``object`` dtype "
"is a constant times the length of the data."
msgstr ""

#: ../../user_guide/categorical.rst:1075
msgid ""
"If the number of categories approaches the length of the data, the "
"``Categorical`` will use nearly the same or more memory than an "
"equivalent ``object`` dtype representation."
msgstr ""

#: ../../user_guide/categorical.rst:1090
msgid "`Categorical` is not a `numpy` array"
msgstr ""

#: ../../user_guide/categorical.rst:1092
msgid ""
"Currently, categorical data and the underlying ``Categorical`` is "
"implemented as a Python object and not as a low-level NumPy array dtype. "
"This leads to some problems."
msgstr ""

#: ../../user_guide/categorical.rst:1095
msgid "NumPy itself doesn't know about the new `dtype`:"
msgstr ""

#: ../../user_guide/categorical.rst:1110
msgid "Dtype comparisons work:"
msgstr ""

#: ../../user_guide/categorical.rst:1117
msgid "To check if a Series contains Categorical data, use ``hasattr(s, 'cat')``:"
msgstr ""

#: ../../user_guide/categorical.rst:1124
msgid ""
"Using NumPy functions on a ``Series`` of type ``category`` should not "
"work as `Categoricals` are not numeric data (even in the case that "
"``.categories`` is numeric)."
msgstr ""

#: ../../user_guide/categorical.rst:1137
msgid ""
"If such a function works, please file a bug at https://github.com/pandas-"
"dev/pandas!"
msgstr ""

#: ../../user_guide/categorical.rst:1140
msgid "dtype in apply"
msgstr ""

#: ../../user_guide/categorical.rst:1142
msgid ""
"Pandas currently does not preserve the dtype in apply functions: If you "
"apply along rows you get a `Series` of ``object`` `dtype` (same as "
"getting a row -> getting one element will return a basic type) and "
"applying along columns will also convert to object. ``NaN`` values are "
"unaffected. You can use ``fillna`` to handle missing values before "
"applying a function."
msgstr ""

#: ../../user_guide/categorical.rst:1156
msgid "Categorical Index"
msgstr ""

#: ../../user_guide/categorical.rst:1158
msgid ""
"``CategoricalIndex`` is a type of index that is useful for supporting "
"indexing with duplicates. This is a container around a ``Categorical`` "
"and allows efficient indexing and storage of an index with a large number"
" of duplicated elements. See the :ref:`advanced indexing docs "
"<indexing.categoricalindex>` for a more detailed explanation."
msgstr ""

#: ../../user_guide/categorical.rst:1164
msgid "Setting the index will create a ``CategoricalIndex``:"
msgstr ""

#: ../../user_guide/categorical.rst:1177
msgid "Side Effects"
msgstr ""

#: ../../user_guide/categorical.rst:1179
msgid ""
"Constructing a ``Series`` from a ``Categorical`` will not copy the input "
"``Categorical``. This means that changes to the ``Series`` will in most "
"cases change the original ``Categorical``:"
msgstr ""

#: ../../user_guide/categorical.rst:1194
msgid ""
"Use ``copy=True`` to prevent such a behaviour or simply don't reuse "
"``Categoricals``:"
msgstr ""

#: ../../user_guide/categorical.rst:1206
msgid ""
"This also happens in some cases when you supply a NumPy array instead of "
"a ``Categorical``: using an int array (e.g. ``np.array([1,2,3,4])``) will"
" exhibit the same behavior, while using a string array (e.g. "
"``np.array([\"a\",\"b\",\"c\",\"a\"])``) will not."
msgstr ""

