# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2008-2014, the pandas development team
# This file is distributed under the same license as the pandas package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: pandas 0.24.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-04-11 11:49+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../user_guide/advanced.rst:3
msgid "{{ header }}"
msgstr ""

#: ../../user_guide/advanced.rst:7
msgid "MultiIndex / Advanced Indexing"
msgstr ""

#: ../../user_guide/advanced.rst:9
msgid ""
"This section covers :ref:`indexing with a MultiIndex "
"<advanced.hierarchical>` and :ref:`other advanced indexing features "
"<indexing.index_types>`."
msgstr ""

#: ../../user_guide/advanced.rst:12
msgid ""
"See the :ref:`Indexing and Selecting Data <indexing>` for general "
"indexing documentation."
msgstr ""

#: ../../user_guide/advanced.rst:16
msgid ""
"Whether a copy or a reference is returned for a setting operation may "
"depend on the context.  This is sometimes called ``chained assignment`` "
"and should be avoided.  See :ref:`Returning a View versus Copy "
"<indexing.view_versus_copy>`."
msgstr ""

#: ../../user_guide/advanced.rst:21
msgid "See the :ref:`cookbook<cookbook.selection>` for some advanced strategies."
msgstr ""

#: ../../user_guide/advanced.rst:26
msgid "Hierarchical indexing (MultiIndex)"
msgstr ""

#: ../../user_guide/advanced.rst:28
msgid ""
"Hierarchical / Multi-level indexing is very exciting as it opens the door"
" to some quite sophisticated data analysis and manipulation, especially "
"for working with higher dimensional data. In essence, it enables you to "
"store and manipulate data with an arbitrary number of dimensions in lower"
" dimensional data structures like ``Series`` (1d) and ``DataFrame`` (2d)."
msgstr ""

#: ../../user_guide/advanced.rst:34
msgid ""
"In this section, we will show what exactly we mean by \"hierarchical\" "
"indexing and how it integrates with all of the pandas indexing "
"functionality described above and in prior sections. Later, when "
"discussing :ref:`group by <groupby>` and :ref:`pivoting and reshaping "
"data <reshaping>`, we'll show non-trivial applications to illustrate how "
"it aids in structuring data for analysis."
msgstr ""

#: ../../user_guide/advanced.rst:41
msgid ""
"See the :ref:`cookbook<cookbook.multi_index>` for some advanced "
"strategies."
msgstr ""

#: ../../user_guide/advanced.rst:45
msgid ""
":attr:`MultiIndex.labels` has been renamed to :attr:`MultiIndex.codes` "
"and :attr:`MultiIndex.set_labels` to :attr:`MultiIndex.set_codes`."
msgstr ""

#: ../../user_guide/advanced.rst:49
msgid "Creating a MultiIndex (hierarchical index) object"
msgstr ""

#: ../../user_guide/advanced.rst:51
msgid ""
"The :class:`MultiIndex` object is the hierarchical analogue of the "
"standard :class:`Index` object which typically stores the axis labels in "
"pandas objects. You can think of ``MultiIndex`` as an array of tuples "
"where each tuple is unique. A ``MultiIndex`` can be created from a list "
"of arrays (using :meth:`MultiIndex.from_arrays`), an array of tuples "
"(using :meth:`MultiIndex.from_tuples`), a crossed set of iterables (using"
" :meth:`MultiIndex.from_product`), or a :class:`DataFrame` (using "
":meth:`MultiIndex.from_frame`).  The ``Index`` constructor will attempt "
"to return a ``MultiIndex`` when it is passed a list of tuples.  The "
"following examples demonstrate different ways to initialize MultiIndexes."
msgstr ""

#: ../../user_guide/advanced.rst:76
msgid ""
"When you want every pairing of the elements in two iterables, it can be "
"easier to use the :meth:`MultiIndex.from_product` method:"
msgstr ""

#: ../../user_guide/advanced.rst:84
msgid ""
"You can also construct a ``MultiIndex`` from a ``DataFrame`` directly, "
"using the method :meth:`MultiIndex.from_frame`. This is a complementary "
"method to :meth:`MultiIndex.to_frame`."
msgstr ""

#: ../../user_guide/advanced.rst:97
msgid ""
"As a convenience, you can pass a list of arrays directly into ``Series`` "
"or ``DataFrame`` to construct a ``MultiIndex`` automatically:"
msgstr ""

#: ../../user_guide/advanced.rst:109
msgid ""
"All of the ``MultiIndex`` constructors accept a ``names`` argument which "
"stores string names for the levels themselves. If no names are provided, "
"``None`` will be assigned:"
msgstr ""

#: ../../user_guide/advanced.rst:117
msgid ""
"This index can back any axis of a pandas object, and the number of "
"**levels** of the index is up to you:"
msgstr ""

#: ../../user_guide/advanced.rst:126
msgid ""
"We've \"sparsified\" the higher levels of the indexes to make the console"
" output a bit easier on the eyes. Note that how the index is displayed "
"can be controlled using the ``multi_sparse`` option in "
"``pandas.set_options()``:"
msgstr ""

#: ../../user_guide/advanced.rst:135
msgid ""
"It's worth keeping in mind that there's nothing preventing you from using"
" tuples as atomic labels on an axis:"
msgstr ""

#: ../../user_guide/advanced.rst:142
msgid ""
"The reason that the ``MultiIndex`` matters is that it can allow you to do"
" grouping, selection, and reshaping operations as we will describe below "
"and in subsequent areas of the documentation. As you will see in later "
"sections, you can find yourself working with hierarchically-indexed data "
"without creating a ``MultiIndex`` explicitly yourself. However, when "
"loading data from a file, you may wish to generate your own "
"``MultiIndex`` when preparing the data set."
msgstr ""

#: ../../user_guide/advanced.rst:152
msgid "Reconstructing the level labels"
msgstr ""

#: ../../user_guide/advanced.rst:154
msgid ""
"The method :meth:`~MultiIndex.get_level_values` will return a vector of "
"the labels for each location at a particular level:"
msgstr ""

#: ../../user_guide/advanced.rst:163
msgid "Basic indexing on axis with MultiIndex"
msgstr ""

#: ../../user_guide/advanced.rst:165
msgid ""
"One of the important features of hierarchical indexing is that you can "
"select data by a \"partial\" label identifying a subgroup in the data. "
"**Partial** selection \"drops\" levels of the hierarchical index in the "
"result in a completely analogous way to selecting a column in a regular "
"DataFrame:"
msgstr ""

#: ../../user_guide/advanced.rst:177
msgid ""
"See :ref:`Cross-section with hierarchical index <advanced.xs>` for how to"
" select on a deeper level."
msgstr ""

#: ../../user_guide/advanced.rst:183
msgid "Defined Levels"
msgstr ""

#: ../../user_guide/advanced.rst:185
msgid ""
"The repr of a ``MultiIndex`` shows all the defined levels of an index, "
"even if they are not actually used. When slicing an index, you may notice"
" this. For example:"
msgstr ""

#: ../../user_guide/advanced.rst:195
msgid ""
"This is done to avoid a recomputation of the levels in order to make "
"slicing highly performant. If you want to see only the used levels, you "
"can use the :meth:`~MultiIndex.get_level_values` method."
msgstr ""

#: ../../user_guide/advanced.rst:206
msgid ""
"To reconstruct the ``MultiIndex`` with only the used levels, the "
":meth:`~MultiIndex.remove_unused_levels` method may be used."
msgstr ""

#: ../../user_guide/advanced.rst:216
msgid "Data alignment and using ``reindex``"
msgstr ""

#: ../../user_guide/advanced.rst:218
msgid ""
"Operations between differently-indexed objects having ``MultiIndex`` on "
"the axes will work as you expect; data alignment will work the same as an"
" Index of tuples:"
msgstr ""

#: ../../user_guide/advanced.rst:227
msgid ""
"The :meth:`~DataFrame.reindex` method of ``Series``/``DataFrames`` can be"
" called with another ``MultiIndex``, or even a list or array of tuples:"
msgstr ""

#: ../../user_guide/advanced.rst:238
msgid "Advanced indexing with hierarchical index"
msgstr ""

#: ../../user_guide/advanced.rst:240
msgid ""
"Syntactically integrating ``MultiIndex`` in advanced indexing with "
"``.loc`` is a bit challenging, but we've made every effort to do so. In "
"general, MultiIndex keys take the form of tuples. For example, the "
"following works as you would expect:"
msgstr ""

#: ../../user_guide/advanced.rst:250
msgid ""
"Note that ``df.loc['bar', 'two']`` would also work in this example, but "
"this shorthand notation can lead to ambiguity in general."
msgstr ""

#: ../../user_guide/advanced.rst:253
msgid ""
"If you also want to index a specific column with ``.loc``, you must use a"
" tuple like this:"
msgstr ""

#: ../../user_guide/advanced.rst:260
msgid ""
"You don't have to specify all levels of the ``MultiIndex`` by passing "
"only the first elements of the tuple. For example, you can use "
"\"partial\" indexing to get all elements with ``bar`` in the first level "
"as follows:"
msgstr ""

#: ../../user_guide/advanced.rst:264
msgid "df.loc['bar']"
msgstr ""

#: ../../user_guide/advanced.rst:266
msgid ""
"This is a shortcut for the slightly more verbose notation "
"``df.loc[('bar',),]`` (equivalent to ``df.loc['bar',]`` in this example)."
msgstr ""

#: ../../user_guide/advanced.rst:269
msgid "\"Partial\" slicing also works quite nicely."
msgstr ""

#: ../../user_guide/advanced.rst:275
msgid "You can slice with a 'range' of values, by providing a slice of tuples."
msgstr ""

#: ../../user_guide/advanced.rst:282
msgid "Passing a list of labels or tuples works similar to reindexing:"
msgstr ""

#: ../../user_guide/advanced.rst:290
msgid ""
"It is important to note that tuples and lists are not treated identically"
" in pandas when it comes to indexing. Whereas a tuple is interpreted as "
"one multi-level key, a list is used to specify several keys. Or in other "
"words, tuples go horizontally (traversing levels), lists go vertically "
"(scanning levels)."
msgstr ""

#: ../../user_guide/advanced.rst:295
msgid ""
"Importantly, a list of tuples indexes several complete ``MultiIndex`` "
"keys, whereas a tuple of lists refer to several values within a level:"
msgstr ""

#: ../../user_guide/advanced.rst:309
msgid "Using slicers"
msgstr ""

#: ../../user_guide/advanced.rst:311
msgid "You can slice a ``MultiIndex`` by providing multiple indexers."
msgstr ""

#: ../../user_guide/advanced.rst:313
msgid ""
"You can provide any of the selectors as if you are indexing by label, see"
" :ref:`Selection by Label <indexing.label>`, including slices, lists of "
"labels, labels, and boolean indexers."
msgstr ""

#: ../../user_guide/advanced.rst:316
msgid ""
"You can use ``slice(None)`` to select all the contents of *that* level. "
"You do not need to specify all the *deeper* levels, they will be implied "
"as ``slice(None)``."
msgstr ""

#: ../../user_guide/advanced.rst:319
msgid ""
"As usual, **both sides** of the slicers are included as this is label "
"indexing."
msgstr ""

#: ../../user_guide/advanced.rst:323
msgid ""
"You should specify all axes in the ``.loc`` specifier, meaning the "
"indexer for the **index** and for the **columns**. There are some "
"ambiguous cases where the passed indexer could be mis-interpreted as "
"indexing *both* axes, rather than into say the ``MultiIndex`` for the "
"rows."
msgstr ""

#: ../../user_guide/advanced.rst:327
msgid "You should do this:"
msgstr ""

#: ../../user_guide/advanced.rst:333
msgid "You should **not** do this:"
msgstr ""

#: ../../user_guide/advanced.rst:357
msgid "Basic MultiIndex slicing using slices, lists, and labels."
msgstr ""

#: ../../user_guide/advanced.rst:364
msgid ""
"You can use :class:`pandas.IndexSlice` to facilitate a more natural "
"syntax using ``:``, rather than using ``slice(None)``."
msgstr ""

#: ../../user_guide/advanced.rst:372
msgid ""
"It is possible to perform quite complicated selections using this method "
"on multiple axes at the same time."
msgstr ""

#: ../../user_guide/advanced.rst:380
msgid "Using a boolean indexer you can provide selection related to the *values*."
msgstr ""

#: ../../user_guide/advanced.rst:387
msgid ""
"You can also specify the ``axis`` argument to ``.loc`` to interpret the "
"passed slicers on a single axis."
msgstr ""

#: ../../user_guide/advanced.rst:394
msgid "Furthermore, you can *set* the values using the following methods."
msgstr ""

#: ../../user_guide/advanced.rst:402
msgid "You can use a right-hand-side of an alignable object as well."
msgstr ""

#: ../../user_guide/advanced.rst:413
msgid "Cross-section"
msgstr ""

#: ../../user_guide/advanced.rst:415
msgid ""
"The :meth:`~DataFrame.xs` method of ``DataFrame`` additionally takes a "
"level argument to make selecting data at a particular level of a "
"``MultiIndex`` easier."
msgstr ""

#: ../../user_guide/advanced.rst:428
msgid ""
"You can also select on the columns with ``xs``, by providing the axis "
"argument."
msgstr ""

#: ../../user_guide/advanced.rst:441
msgid "``xs`` also allows selection with multiple keys."
msgstr ""

#: ../../user_guide/advanced.rst:452
msgid ""
"You can pass ``drop_level=False`` to ``xs`` to retain the level that was "
"selected."
msgstr ""

#: ../../user_guide/advanced.rst:459
msgid ""
"Compare the above with the result using ``drop_level=True`` (the default "
"value)."
msgstr ""

#: ../../user_guide/advanced.rst:473
msgid "Advanced reindexing and alignment"
msgstr ""

#: ../../user_guide/advanced.rst:475
msgid ""
"Using the parameter ``level`` in the :meth:`~DataFrame.reindex` and "
":meth:`~DataFrame.align` methods of pandas objects is useful to broadcast"
" values across a level. For instance:"
msgstr ""

#: ../../user_guide/advanced.rst:496
msgid "Swapping levels with ``swaplevel``"
msgstr ""

#: ../../user_guide/advanced.rst:498
msgid ""
"The :meth:`~MultiIndex.swaplevel` method can switch the order of two "
"levels:"
msgstr ""

#: ../../user_guide/advanced.rst:508
msgid "Reordering levels with ``reorder_levels``"
msgstr ""

#: ../../user_guide/advanced.rst:510
msgid ""
"The :meth:`~MultiIndex.reorder_levels` method generalizes the "
"``swaplevel`` method, allowing you to permute the hierarchical index "
"levels in one step:"
msgstr ""

#: ../../user_guide/advanced.rst:520
msgid "Renaming names of an ``Index`` or ``MultiIndex``"
msgstr ""

#: ../../user_guide/advanced.rst:522
msgid ""
"The :meth:`~DataFrame.rename` method is used to rename the labels of a "
"``MultiIndex``, and is typically used to rename the columns of a "
"``DataFrame``. The ``columns`` argument of ``rename`` allows a dictionary"
" to be specified that includes only the columns you wish to rename."
msgstr ""

#: ../../user_guide/advanced.rst:531
msgid ""
"This method can also be used to rename specific labels of the main index "
"of the ``DataFrame``."
msgstr ""

#: ../../user_guide/advanced.rst:538
msgid ""
"The :meth:`~DataFrame.rename_axis` method is used to rename the name of a"
" ``Index`` or ``MultiIndex``. In particular, the names of the levels of a"
" ``MultiIndex`` can be specified, which is useful if ``reset_index()`` is"
" later used to move the values from the ``MultiIndex`` to a column."
msgstr ""

#: ../../user_guide/advanced.rst:547
msgid ""
"Note that the columns of a ``DataFrame`` are an index, so that using "
"``rename_axis`` with the ``columns`` argument will change the name of "
"that index."
msgstr ""

#: ../../user_guide/advanced.rst:555
msgid ""
"Both ``rename`` and ``rename_axis`` support specifying a dictionary, "
"``Series`` or a mapping function to map labels/names to new values."
msgstr ""

#: ../../user_guide/advanced.rst:559
msgid "Sorting a ``MultiIndex``"
msgstr ""

#: ../../user_guide/advanced.rst:561
msgid ""
"For :class:`MultiIndex`-ed objects to be indexed and sliced effectively, "
"they need to be sorted. As with any index, you can use "
":meth:`~DataFrame.sort_index`."
msgstr ""

#: ../../user_guide/advanced.rst:576
msgid ""
"You may also pass a level name to ``sort_index`` if the ``MultiIndex`` "
"levels are named."
msgstr ""

#: ../../user_guide/advanced.rst:585
msgid ""
"On higher dimensional objects, you can sort any of the other axes by "
"level if they have a ``MultiIndex``:"
msgstr ""

#: ../../user_guide/advanced.rst:592
msgid ""
"Indexing will work even if the data are not sorted, but will be rather "
"inefficient (and show a ``PerformanceWarning``). It will also return a "
"copy of the data rather than a view:"
msgstr ""

#: ../../user_guide/advanced.rst:616
msgid ""
"Furthermore, if you try to index something that is not fully lexsorted, "
"this can raise:"
msgstr ""

#: ../../user_guide/advanced.rst:623
msgid ""
"The :meth:`~MultiIndex.is_lexsorted` method on a ``MultiIndex`` shows if "
"the index is sorted, and the ``lexsort_depth`` property returns the sort "
"depth:"
msgstr ""

#: ../../user_guide/advanced.rst:638
msgid "And now selection works as expected."
msgstr ""

#: ../../user_guide/advanced.rst:645
msgid "Take Methods"
msgstr ""

#: ../../user_guide/advanced.rst:649
msgid ""
"Similar to NumPy ndarrays, pandas ``Index``, ``Series``, and "
"``DataFrame`` also provides the :meth:`~DataFrame.take` method that "
"retrieves elements along a given axis at the given indices. The given "
"indices must be either a list or an ndarray of integer index positions. "
"``take`` will also accept negative integers as relative positions to the "
"end of the object."
msgstr ""

#: ../../user_guide/advanced.rst:669
msgid ""
"For DataFrames, the given indices should be a 1d list or ndarray that "
"specifies row or column positions."
msgstr ""

#: ../../user_guide/advanced.rst:680
msgid ""
"It is important to note that the ``take`` method on pandas objects are "
"not intended to work on boolean indices and may return unexpected "
"results."
msgstr ""

#: ../../user_guide/advanced.rst:693
msgid ""
"Finally, as a small note on performance, because the ``take`` method "
"handles a narrower range of inputs, it can offer performance that is a "
"good deal faster than fancy indexing."
msgstr ""

#: ../../user_guide/advanced.rst:713
msgid "Index Types"
msgstr ""

#: ../../user_guide/advanced.rst:715
msgid ""
"We have discussed ``MultiIndex`` in the previous sections pretty "
"extensively. Documentation about ``DatetimeIndex`` and ``PeriodIndex`` "
"are shown :ref:`here <timeseries.overview>`, and documentation about "
"``TimedeltaIndex`` is found :ref:`here <timedeltas.index>`."
msgstr ""

#: ../../user_guide/advanced.rst:719
msgid "In the following sub-sections we will highlight some other index types."
msgstr ""

#: ../../user_guide/advanced.rst:724
msgid "CategoricalIndex"
msgstr ""

#: ../../user_guide/advanced.rst:726
msgid ""
":class:`CategoricalIndex` is a type of index that is useful for "
"supporting indexing with duplicates. This is a container around a "
":class:`Categorical` and allows efficient indexing and storage of an "
"index with a large number of duplicated elements."
msgstr ""

#: ../../user_guide/advanced.rst:740
msgid "Setting the index will create a ``CategoricalIndex``."
msgstr ""

#: ../../user_guide/advanced.rst:747
msgid ""
"Indexing with ``__getitem__/.iloc/.loc`` works similarly to an ``Index`` "
"with duplicates. The indexers **must** be in the category or the "
"operation will raise a ``KeyError``."
msgstr ""

#: ../../user_guide/advanced.rst:754
msgid "The ``CategoricalIndex`` is **preserved** after indexing:"
msgstr ""

#: ../../user_guide/advanced.rst:760
msgid ""
"Sorting the index will sort by the order of the categories (recall that "
"we created the index with ``CategoricalDtype(list('cab'))``, so the "
"sorted order is ``cab``)."
msgstr ""

#: ../../user_guide/advanced.rst:768
msgid "Groupby operations on the index will preserve the index nature as well."
msgstr ""

#: ../../user_guide/advanced.rst:775
msgid ""
"Reindexing operations will return a resulting index based on the type of "
"the passed indexer. Passing a list will return a plain-old ``Index``; "
"indexing with a ``Categorical`` will return a ``CategoricalIndex``, "
"indexed according to the categories of the **passed** ``Categorical`` "
"dtype. This allows one to arbitrarily index these even with values "
"**not** in the categories, similarly to how you can reindex **any** "
"pandas index."
msgstr ""

#: ../../user_guide/advanced.rst:790
msgid ""
"Reshaping and Comparison operations on a ``CategoricalIndex`` must have "
"the same categories or a ``TypeError`` will be raised."
msgstr ""

#: ../../user_guide/advanced.rst:808
msgid "Int64Index and RangeIndex"
msgstr ""

#: ../../user_guide/advanced.rst:812
msgid ""
"Indexing on an integer-based Index with floats has been clarified in "
"0.18.0, for a summary of the changes, see :ref:`here "
"<whatsnew_0180.float_indexers>`."
msgstr ""

#: ../../user_guide/advanced.rst:814
msgid ""
":class:`Int64Index` is a fundamental basic index in pandas. This is an "
"immutable array implementing an ordered, sliceable set. Prior to 0.18.0, "
"the ``Int64Index`` would provide the default index for all ``NDFrame`` "
"objects."
msgstr ""

#: ../../user_guide/advanced.rst:818
msgid ""
":class:`RangeIndex` is a sub-class of ``Int64Index`` added in version "
"0.18.0, now providing the default index for all ``NDFrame`` objects. "
"``RangeIndex`` is an optimized version of ``Int64Index`` that can "
"represent a monotonic ordered set. These are analogous to Python `range "
"types <https://docs.python.org/3/library/stdtypes.html#typesseq-"
"range>`__."
msgstr ""

#: ../../user_guide/advanced.rst:824
msgid "Float64Index"
msgstr ""

#: ../../user_guide/advanced.rst:826
msgid ""
"By default a :class:`Float64Index` will be automatically created when "
"passing floating, or mixed-integer-floating values in index creation. "
"This enables a pure label-based slicing paradigm that makes ``[],ix,loc``"
" for scalar indexing and slicing work exactly the same."
msgstr ""

#: ../../user_guide/advanced.rst:837
msgid ""
"Scalar selection for ``[],.loc`` will always be label based. An integer "
"will match an equal float index (e.g. ``3`` is equivalent to ``3.0``)."
msgstr ""

#: ../../user_guide/advanced.rst:846
msgid "The only positional indexing is via ``iloc``."
msgstr ""

#: ../../user_guide/advanced.rst:852
msgid ""
"A scalar index that is not found will raise a ``KeyError``. Slicing is "
"primarily on the values of the index when using ``[],ix,loc``, and "
"**always** positional when using ``iloc``. The exception is when the "
"slice is boolean, in which case it will always be positional."
msgstr ""

#: ../../user_guide/advanced.rst:863
msgid "In float indexes, slicing using floats is allowed."
msgstr ""

#: ../../user_guide/advanced.rst:870
msgid "In non-float indexes, slicing using floats will raise a ``TypeError``."
msgstr ""

#: ../../user_guide/advanced.rst:882
msgid ""
"Using a scalar float indexer for ``.iloc`` has been removed in 0.18.0, so"
" the following will raise a ``TypeError``:"
msgstr ""

#: ../../user_guide/advanced.rst:890
msgid ""
"Here is a typical use-case for using this type of indexing. Imagine that "
"you have a somewhat irregular timedelta-like indexing scheme, but the "
"data is recorded as floats. This could, for example, be millisecond "
"offsets."
msgstr ""

#: ../../user_guide/advanced.rst:904
msgid ""
"Selection operations then will always work on a value basis, for all "
"selection operators."
msgstr ""

#: ../../user_guide/advanced.rst:912
msgid "You could retrieve the first 1 second (1000 ms) of data as such:"
msgstr ""

#: ../../user_guide/advanced.rst:918
msgid "If you need integer based selection, you should use ``iloc``:"
msgstr ""

#: ../../user_guide/advanced.rst:927
msgid "IntervalIndex"
msgstr ""

#: ../../user_guide/advanced.rst:931
msgid ""
":class:`IntervalIndex` together with its own dtype, "
":class:`~pandas.api.types.IntervalDtype` as well as the :class:`Interval`"
" scalar type,  allow first-class support in pandas for interval notation."
msgstr ""

#: ../../user_guide/advanced.rst:935
msgid ""
"The ``IntervalIndex`` allows some unique indexing and is also used as a "
"return type for the categories in :func:`cut` and :func:`qcut`."
msgstr ""

#: ../../user_guide/advanced.rst:940
msgid ""
"These indexing behaviors are provisional and may change in a future "
"version of pandas."
msgstr ""

#: ../../user_guide/advanced.rst:942
msgid ""
"An ``IntervalIndex`` can be used in ``Series`` and in ``DataFrame`` as "
"the index."
msgstr ""

#: ../../user_guide/advanced.rst:950
msgid ""
"Label based indexing via ``.loc`` along the edges of an interval works as"
" you would expect, selecting that particular interval."
msgstr ""

#: ../../user_guide/advanced.rst:958
msgid ""
"If you select a label *contained* within an interval, this will also "
"select the interval."
msgstr ""

#: ../../user_guide/advanced.rst:965
msgid "``Interval`` and ``IntervalIndex`` are used by ``cut`` and ``qcut``:"
msgstr ""

#: ../../user_guide/advanced.rst:973
msgid ""
"Furthermore, ``IntervalIndex`` allows one to bin *other* data with these "
"same bins, with ``NaN`` representing a missing value similar to other "
"dtypes."
msgstr ""

#: ../../user_guide/advanced.rst:982
msgid "Generating Ranges of Intervals"
msgstr ""

#: ../../user_guide/advanced.rst:984
msgid ""
"If we need intervals on a regular frequency, we can use the "
":func:`interval_range` function to create an ``IntervalIndex`` using "
"various combinations of ``start``, ``end``, and ``periods``. The default "
"frequency for ``interval_range`` is a 1 for numeric intervals, and "
"calendar day for datetime-like intervals:"
msgstr ""

#: ../../user_guide/advanced.rst:997
msgid ""
"The ``freq`` parameter can used to specify non-default frequencies, and "
"can utilize a variety of :ref:`frequency aliases "
"<timeseries.offset_aliases>` with datetime-like intervals:"
msgstr ""

#: ../../user_guide/advanced.rst:1008
msgid ""
"Additionally, the ``closed`` parameter can be used to specify which "
"side(s) the intervals are closed on.  Intervals are closed on the right "
"side by default."
msgstr ""

#: ../../user_guide/advanced.rst:1019
msgid ""
"Specifying ``start``, ``end``, and ``periods`` will generate a range of "
"evenly spaced intervals from ``start`` to ``end`` inclusively, with "
"``periods`` number of elements in the resulting ``IntervalIndex``:"
msgstr ""

#: ../../user_guide/advanced.rst:1031
msgid "Miscellaneous indexing FAQ"
msgstr ""

#: ../../user_guide/advanced.rst:1034
msgid "Integer indexing"
msgstr ""

#: ../../user_guide/advanced.rst:1036
msgid ""
"Label-based indexing with integer axis labels is a thorny topic. It has "
"been discussed heavily on mailing lists and among various members of the "
"scientific Python community. In pandas, our general viewpoint is that "
"labels matter more than integer locations. Therefore, with an integer "
"axis index *only* label-based indexing is possible with the standard "
"tools like ``.loc``. The following code will generate exceptions:"
msgstr ""

#: ../../user_guide/advanced.rst:1052
msgid ""
"This deliberate decision was made to prevent ambiguities and subtle bugs "
"(many users reported finding bugs when the API change was made to stop "
"\"falling back\" on position-based indexing)."
msgstr ""

#: ../../user_guide/advanced.rst:1057
msgid "Non-monotonic indexes require exact matches"
msgstr ""

#: ../../user_guide/advanced.rst:1059
msgid ""
"If the index of a ``Series`` or ``DataFrame`` is monotonically increasing"
" or decreasing, then the bounds of a label-based slice can be outside the"
" range of the index, much like slice indexing a normal Python ``list``. "
"Monotonicity of an index can be tested with the "
":meth:`~Index.is_monotonic_increasing` and "
":meth:`~Index.is_monotonic_decreasing` attributes."
msgstr ""

#: ../../user_guide/advanced.rst:1075
msgid ""
"On the other hand, if the index is not monotonic, then both slice bounds "
"must be *unique* members of the index."
msgstr ""

#: ../../user_guide/advanced.rst:1097
msgid ""
"``Index.is_monotonic_increasing`` and ``Index.is_monotonic_decreasing`` "
"only check that an index is weakly monotonic. To check for strict "
"monotonicity, you can combine one of those with the "
":meth:`~Index.is_unique` attribute."
msgstr ""

#: ../../user_guide/advanced.rst:1109
msgid "Endpoints are inclusive"
msgstr ""

#: ../../user_guide/advanced.rst:1111
msgid ""
"Compared with standard Python sequence slicing in which the slice "
"endpoint is not inclusive, label-based slicing in pandas **is "
"inclusive**. The primary reason for this is that it is often not possible"
" to easily determine the \"successor\" or next element after a particular"
" label in an index. For example, consider the following ``Series``:"
msgstr ""

#: ../../user_guide/advanced.rst:1122
msgid ""
"Suppose we wished to slice from ``c`` to ``e``, using integers this would"
" be accomplished as such:"
msgstr ""

#: ../../user_guide/advanced.rst:1129
msgid ""
"However, if you only had ``c`` and ``e``, determining the next element in"
" the index can be somewhat complicated. For example, the following does "
"not work:"
msgstr ""

#: ../../user_guide/advanced.rst:1136
msgid ""
"A very common use case is to limit a time series to start and end at two "
"specific dates. To enable this, we made the design to make label-based "
"slicing include both endpoints:"
msgstr ""

#: ../../user_guide/advanced.rst:1144
msgid ""
"This is most definitely a \"practicality beats purity\" sort of thing, "
"but it is something to watch out for if you expect label-based slicing to"
" behave exactly in the way that standard Python integer slicing works."
msgstr ""

#: ../../user_guide/advanced.rst:1150
msgid "Indexing potentially changes underlying Series dtype"
msgstr ""

#: ../../user_guide/advanced.rst:1152
msgid ""
"The different indexing operation can potentially change the dtype of a "
"``Series``."
msgstr ""

#: ../../user_guide/advanced.rst:1170
msgid ""
"This is because the (re)indexing operations above silently inserts "
"``NaNs`` and the ``dtype`` changes accordingly.  This can cause some "
"issues when using ``numpy`` ``ufuncs`` such as ``numpy.logical_and``."
msgstr ""

#: ../../user_guide/advanced.rst:1174
msgid ""
"See the `this old issue <https://github.com/pydata/pandas/issues/2388>`__"
" for a more detailed discussion."
msgstr ""

