# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2008-2014, the pandas development team
# This file is distributed under the same license as the pandas package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: pandas 0.24.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-04-11 11:49+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../user_guide/indexing.rst:3
msgid "{{ header }}"
msgstr ""

#: ../../user_guide/indexing.rst:7
msgid "Indexing and Selecting Data"
msgstr ""

#: ../../user_guide/indexing.rst:9
msgid "The axis labeling information in pandas objects serves many purposes:"
msgstr ""

#: ../../user_guide/indexing.rst:11
msgid ""
"Identifies data (i.e. provides *metadata*) using known indicators, "
"important for analysis, visualization, and interactive console display."
msgstr ""

#: ../../user_guide/indexing.rst:13
msgid "Enables automatic and explicit data alignment."
msgstr ""

#: ../../user_guide/indexing.rst:14
msgid "Allows intuitive getting and setting of subsets of the data set."
msgstr ""

#: ../../user_guide/indexing.rst:16
msgid ""
"In this section, we will focus on the final point: namely, how to slice, "
"dice, and generally get and set subsets of pandas objects. The primary "
"focus will be on Series and DataFrame as they have received more "
"development attention in this area."
msgstr ""

#: ../../user_guide/indexing.rst:23
msgid ""
"The Python and NumPy indexing operators ``[]`` and attribute operator "
"``.`` provide quick and easy access to pandas data structures across a "
"wide range of use cases. This makes interactive work intuitive, as "
"there's little new to learn if you already know how to deal with Python "
"dictionaries and NumPy arrays. However, since the type of the data to be "
"accessed isn't known in advance, directly using standard operators has "
"some optimization limits. For production code, we recommended that you "
"take advantage of the optimized pandas data access methods exposed in "
"this chapter."
msgstr ""

#: ../../user_guide/indexing.rst:34 ../../user_guide/indexing.rst:295
#: ../../user_guide/indexing.rst:428
msgid ""
"Whether a copy or a reference is returned for a setting operation, may "
"depend on the context. This is sometimes called ``chained assignment`` "
"and should be avoided. See :ref:`Returning a View versus Copy "
"<indexing.view_versus_copy>`."
msgstr ""

#: ../../user_guide/indexing.rst:41
msgid ""
"Indexing on an integer-based Index with floats has been clarified in "
"0.18.0, for a summary of the changes, see :ref:`here "
"<whatsnew_0180.float_indexers>`."
msgstr ""

#: ../../user_guide/indexing.rst:43
msgid ""
"See the :ref:`MultiIndex / Advanced Indexing <advanced>` for "
"``MultiIndex`` and more advanced indexing documentation."
msgstr ""

#: ../../user_guide/indexing.rst:45
msgid "See the :ref:`cookbook<cookbook.selection>` for some advanced strategies."
msgstr ""

#: ../../user_guide/indexing.rst:50
msgid "Different Choices for Indexing"
msgstr ""

#: ../../user_guide/indexing.rst:52
msgid ""
"Object selection has had a number of user-requested additions in order to"
" support more explicit location based indexing. Pandas now supports three"
" types of multi-axis indexing."
msgstr ""

#: ../../user_guide/indexing.rst:56
msgid ""
"``.loc`` is primarily label based, but may also be used with a boolean "
"array. ``.loc`` will raise ``KeyError`` when the items are not found. "
"Allowed inputs are:"
msgstr ""

#: ../../user_guide/indexing.rst:58 ../../user_guide/indexing.rst:334
msgid ""
"A single label, e.g. ``5`` or ``'a'`` (Note that ``5`` is interpreted as "
"a *label* of the index. This use is **not** an integer position along the"
" index.)."
msgstr ""

#: ../../user_guide/indexing.rst:61 ../../user_guide/indexing.rst:335
msgid "A list or array of labels ``['a', 'b', 'c']``."
msgstr ""

#: ../../user_guide/indexing.rst:62 ../../user_guide/indexing.rst:336
msgid ""
"A slice object with labels ``'a':'f'`` (Note that contrary to usual "
"python slices, **both** the start and the stop are included, when present"
" in the index! See :ref:`Slicing with labels "
"<indexing.slicing_with_labels>`.)."
msgstr ""

#: ../../user_guide/indexing.rst:66
msgid "A boolean array"
msgstr ""

#: ../../user_guide/indexing.rst:67 ../../user_guide/indexing.rst:85
msgid ""
"A ``callable`` function with one argument (the calling Series or "
"DataFrame) and that returns valid output for indexing (one of the above)."
msgstr ""

#: ../../user_guide/indexing.rst:72
msgid "See more at :ref:`Selection by Label <indexing.label>`."
msgstr ""

#: ../../user_guide/indexing.rst:74
msgid ""
"``.iloc`` is primarily integer position based (from ``0`` to ``length-1``"
" of the axis), but may also be used with a boolean array.  ``.iloc`` will"
" raise ``IndexError`` if a requested indexer is out-of-bounds, except "
"*slice* indexers which allow out-of-bounds indexing.  (this conforms with"
" Python/NumPy *slice* semantics).  Allowed inputs are:"
msgstr ""

#: ../../user_guide/indexing.rst:81 ../../user_guide/indexing.rst:436
msgid "An integer e.g. ``5``."
msgstr ""

#: ../../user_guide/indexing.rst:82 ../../user_guide/indexing.rst:437
msgid "A list or array of integers ``[4, 3, 0]``."
msgstr ""

#: ../../user_guide/indexing.rst:83 ../../user_guide/indexing.rst:438
msgid "A slice object with ints ``1:7``."
msgstr ""

#: ../../user_guide/indexing.rst:84 ../../user_guide/indexing.rst:340
#: ../../user_guide/indexing.rst:439
msgid "A boolean array."
msgstr ""

#: ../../user_guide/indexing.rst:90
msgid ""
"See more at :ref:`Selection by Position <indexing.integer>`, "
":ref:`Advanced Indexing <advanced>` and :ref:`Advanced Hierarchical "
"<advanced.advanced_hierarchical>`."
msgstr ""

#: ../../user_guide/indexing.rst:94
msgid ""
"``.loc``, ``.iloc``, and also ``[]`` indexing can accept a ``callable`` "
"as indexer. See more at :ref:`Selection By Callable <indexing.callable>`."
msgstr ""

#: ../../user_guide/indexing.rst:96
msgid ""
"Getting values from an object with multi-axes selection uses the "
"following notation (using ``.loc`` as an example, but the following "
"applies to ``.iloc`` as well). Any of the axes accessors may be the null "
"slice ``:``. Axes left out of the specification are assumed to be ``:``, "
"e.g. ``p.loc['a']`` is equivalent to ``p.loc['a', :, :]``."
msgstr ""

#: ../../user_guide/indexing.rst:1
msgid "Object Type"
msgstr ""

#: ../../user_guide/indexing.rst:1
msgid "Indexers"
msgstr ""

#: ../../user_guide/indexing.rst:1
msgid "Series"
msgstr ""

#: ../../user_guide/indexing.rst:1
msgid "``s.loc[indexer]``"
msgstr ""

#: ../../user_guide/indexing.rst:1
msgid "DataFrame"
msgstr ""

#: ../../user_guide/indexing.rst:1
msgid "``df.loc[row_indexer,column_indexer]``"
msgstr ""

#: ../../user_guide/indexing.rst:113
msgid "Basics"
msgstr ""

#: ../../user_guide/indexing.rst:115
msgid ""
"As mentioned when introducing the data structures in the :ref:`last "
"section <basics>`, the primary function of indexing with ``[]`` (a.k.a. "
"``__getitem__`` for those familiar with implementing class behavior in "
"Python) is selecting out lower-dimensional slices. The following table "
"shows return type values when indexing pandas objects with ``[]``:"
msgstr ""

#: ../../user_guide/indexing.rst:1
msgid "Selection"
msgstr ""

#: ../../user_guide/indexing.rst:1
msgid "Return Value Type"
msgstr ""

#: ../../user_guide/indexing.rst:1
msgid "``series[label]``"
msgstr ""

#: ../../user_guide/indexing.rst:1
msgid "scalar value"
msgstr ""

#: ../../user_guide/indexing.rst:1
msgid "``frame[colname]``"
msgstr ""

#: ../../user_guide/indexing.rst:1
msgid "``Series`` corresponding to colname"
msgstr ""

#: ../../user_guide/indexing.rst:129
msgid ""
"Here we construct a simple time series data set to use for illustrating "
"the indexing functionality:"
msgstr ""

#: ../../user_guide/indexing.rst:141
msgid ""
"None of the indexing functionality is time series specific unless "
"specifically stated."
msgstr ""

#: ../../user_guide/indexing.rst:144
msgid "Thus, as per above, we have the most basic indexing using ``[]``:"
msgstr ""

#: ../../user_guide/indexing.rst:151
msgid ""
"You can pass a list of columns to ``[]`` to select columns in that order."
" If a column is not contained in the DataFrame, an exception will be "
"raised. Multiple columns can also be set in this manner:"
msgstr ""

#: ../../user_guide/indexing.rst:161
msgid ""
"You may find this useful for applying a transform (in-place) to a subset "
"of the columns."
msgstr ""

#: ../../user_guide/indexing.rst:166
msgid ""
"pandas aligns all AXES when setting ``Series`` and ``DataFrame`` from "
"``.loc``, and ``.iloc``."
msgstr ""

#: ../../user_guide/indexing.rst:168
msgid ""
"This will **not** modify ``df`` because the column alignment is before "
"value assignment."
msgstr ""

#: ../../user_guide/indexing.rst:176
msgid "The correct way to swap column values is by using raw values:"
msgstr ""

#: ../../user_guide/indexing.rst:185
msgid "Attribute Access"
msgstr ""

#: ../../user_guide/indexing.rst:193
msgid ""
"You may access an index on a ``Series`` or  column on a ``DataFrame`` "
"directly as an attribute:"
msgstr ""

#: ../../user_guide/indexing.rst:217
msgid ""
"You can use this access only if the index element is a valid Python "
"identifier, e.g. ``s.1`` is not allowed. See `here for an explanation of "
"valid identifiers "
"<https://docs.python.org/3/reference/lexical_analysis.html#identifiers>`__."
msgstr ""

#: ../../user_guide/indexing.rst:221
msgid ""
"The attribute will not be available if it conflicts with an existing "
"method name, e.g. ``s.min`` is not allowed."
msgstr ""

#: ../../user_guide/indexing.rst:223
msgid ""
"Similarly, the attribute will not be available if it conflicts with any "
"of the following list: ``index``, ``major_axis``, ``minor_axis``, "
"``items``."
msgstr ""

#: ../../user_guide/indexing.rst:226
msgid ""
"In any of these cases, standard indexing will still work, e.g. "
"``s['1']``, ``s['min']``, and ``s['index']`` will access the "
"corresponding element or column."
msgstr ""

#: ../../user_guide/indexing.rst:229
msgid ""
"If you are using the IPython environment, you may also use tab-completion"
" to see these accessible attributes."
msgstr ""

#: ../../user_guide/indexing.rst:232
msgid "You can also assign a ``dict`` to a row of a ``DataFrame``:"
msgstr ""

#: ../../user_guide/indexing.rst:240
msgid ""
"You can use attribute access to modify an existing element of a Series or"
" column of a DataFrame, but be careful; if you try to use attribute "
"access to create a new column, it creates a new attribute rather than a "
"new column. In 0.21.0 and later, this will raise a ``UserWarning``:"
msgstr ""

#: ../../user_guide/indexing.rst:257
msgid "Slicing ranges"
msgstr ""

#: ../../user_guide/indexing.rst:259
msgid ""
"The most robust and consistent way of slicing ranges along arbitrary axes"
" is described in the :ref:`Selection by Position <indexing.integer>` "
"section detailing the ``.iloc`` method. For now, we explain the semantics"
" of slicing using the ``[]`` operator."
msgstr ""

#: ../../user_guide/indexing.rst:263
msgid ""
"With Series, the syntax works exactly as with an ndarray, returning a "
"slice of the values and the corresponding labels:"
msgstr ""

#: ../../user_guide/indexing.rst:272 ../../user_guide/indexing.rst:350
#: ../../user_guide/indexing.rst:449
msgid "Note that setting works as well:"
msgstr ""

#: ../../user_guide/indexing.rst:280
msgid ""
"With DataFrame, slicing inside of ``[]`` **slices the rows**. This is "
"provided largely as a convenience since it is such a common operation."
msgstr ""

#: ../../user_guide/indexing.rst:291
msgid "Selection By Label"
msgstr ""

#: ../../user_guide/indexing.rst:301
msgid ""
"``.loc`` is strict when you present slicers that are not compatible (or "
"convertible) with the index type. For example using integers in a "
"``DatetimeIndex``. These will raise a ``TypeError``."
msgstr ""

#: ../../user_guide/indexing.rst:316
msgid ""
"String likes in slicing *can* be convertible to the type of the index and"
" lead to natural slicing."
msgstr ""

#: ../../user_guide/indexing.rst:324
msgid ""
"Starting in 0.21.0, pandas will show a ``FutureWarning`` if indexing with"
" a list with missing labels. In the future this will raise a "
"``KeyError``. See :ref:`list-like Using loc with missing keys in a list "
"is Deprecated <indexing.deprecate_loc_reindex_listlike>`."
msgstr ""

#: ../../user_guide/indexing.rst:327
msgid ""
"pandas provides a suite of methods in order to have **purely label based "
"indexing**. This is a strict inclusion based protocol. Every label asked "
"for must be in the index, or a ``KeyError`` will be raised. When slicing,"
" both the start bound **AND** the stop bound are *included*, if present "
"in the index. Integers are valid labels, but they refer to the label "
"**and not the position**."
msgstr ""

#: ../../user_guide/indexing.rst:332
msgid ""
"The ``.loc`` attribute is the primary access method. The following are "
"valid inputs:"
msgstr ""

#: ../../user_guide/indexing.rst:341 ../../user_guide/indexing.rst:440
msgid "A ``callable``, see :ref:`Selection By Callable <indexing.callable>`."
msgstr ""

#: ../../user_guide/indexing.rst:357 ../../user_guide/indexing.rst:456
msgid "With a DataFrame:"
msgstr ""

#: ../../user_guide/indexing.rst:367
msgid "Accessing via label slices:"
msgstr ""

#: ../../user_guide/indexing.rst:373
msgid "For getting a cross section using a label (equivalent to ``df.xs('a')``):"
msgstr ""

#: ../../user_guide/indexing.rst:379
msgid "For getting values with a boolean array:"
msgstr ""

#: ../../user_guide/indexing.rst:386
msgid ""
"For getting a value explicitly (equivalent to deprecated "
"``df.get_value('a','A')``):"
msgstr ""

#: ../../user_guide/indexing.rst:396
msgid "Slicing with labels"
msgstr ""

#: ../../user_guide/indexing.rst:398
msgid ""
"When using ``.loc`` with slices, if both the start and the stop labels "
"are present in the index, then elements *located* between the two "
"(including them) are returned:"
msgstr ""

#: ../../user_guide/indexing.rst:407
msgid ""
"If at least one of the two is absent, but the index is sorted, and can be"
" compared against start and stop labels, then slicing will still work as "
"expected, by selecting labels which *rank* between the two:"
msgstr ""

#: ../../user_guide/indexing.rst:416
msgid ""
"However, if at least one of the two is absent *and* the index is not "
"sorted, an error will be raised (since doing otherwise would be "
"computationally expensive, as well as potentially ambiguous for mixed "
"type indexes). For instance, in the above example, ``s.loc[1:6]`` would "
"raise ``KeyError``."
msgstr ""

#: ../../user_guide/indexing.rst:424
msgid "Selection By Position"
msgstr ""

#: ../../user_guide/indexing.rst:432
msgid ""
"Pandas provides a suite of methods in order to get **purely integer based"
" indexing**. The semantics follow closely Python and NumPy slicing. These"
" are ``0-based`` indexing. When slicing, the start bound is *included*, "
"while the upper bound is *excluded*. Trying to use a non-integer, even a "
"**valid** label will raise an ``IndexError``."
msgstr ""

#: ../../user_guide/indexing.rst:434
msgid ""
"The ``.iloc`` attribute is the primary access method. The following are "
"valid inputs:"
msgstr ""

#: ../../user_guide/indexing.rst:465
msgid "Select via integer slicing:"
msgstr ""

#: ../../user_guide/indexing.rst:472
msgid "Select via integer list:"
msgstr ""

#: ../../user_guide/indexing.rst:491
msgid ""
"For getting a cross section using an integer position (equiv to "
"``df.xs(1)``):"
msgstr ""

#: ../../user_guide/indexing.rst:497
msgid "Out of range slice indexes are handled gracefully just as in Python/Numpy."
msgstr ""

#: ../../user_guide/indexing.rst:511
msgid ""
"Note that using slices that go out of bounds can result in an empty axis "
"(e.g. an empty DataFrame being returned)."
msgstr ""

#: ../../user_guide/indexing.rst:522
msgid ""
"A single indexer that is out of bounds will raise an ``IndexError``. A "
"list of indexers where any element is out of bounds will raise an "
"``IndexError``."
msgstr ""

#: ../../user_guide/indexing.rst:537
msgid "Selection By Callable"
msgstr ""

#: ../../user_guide/indexing.rst:541
msgid ""
"``.loc``, ``.iloc``, and also ``[]`` indexing can accept a ``callable`` "
"as indexer. The ``callable`` must be a function with one argument (the "
"calling Series or DataFrame) that returns valid output for indexing."
msgstr ""

#: ../../user_guide/indexing.rst:559
msgid "You can use callable indexing in ``Series``."
msgstr ""

#: ../../user_guide/indexing.rst:565
msgid ""
"Using these methods / indexers, you can chain data selection operations "
"without using a temporary variable."
msgstr ""

#: ../../user_guide/indexing.rst:577
msgid "IX Indexer is Deprecated"
msgstr ""

#: ../../user_guide/indexing.rst:581
msgid ""
"Starting in 0.20.0, the ``.ix`` indexer is deprecated, in favor of the "
"more strict ``.iloc`` and ``.loc`` indexers."
msgstr ""

#: ../../user_guide/indexing.rst:584
msgid ""
"``.ix`` offers a lot of magic on the inference of what the user wants to "
"do. To wit, ``.ix`` can decide to index *positionally* OR via *labels* "
"depending on the data type of the index. This has caused quite a bit of "
"user confusion over the years."
msgstr ""

#: ../../user_guide/indexing.rst:588
msgid "The recommended methods of indexing are:"
msgstr ""

#: ../../user_guide/indexing.rst:590
msgid "``.loc`` if you want to *label* index."
msgstr ""

#: ../../user_guide/indexing.rst:591
msgid "``.iloc`` if you want to *positionally* index."
msgstr ""

#: ../../user_guide/indexing.rst:601
msgid ""
"Previous behavior, where you wish to get the 0th and the 2nd elements "
"from the index in the 'A' column."
msgstr ""

#: ../../user_guide/indexing.rst:611
msgid ""
"Using ``.loc``. Here we will select the appropriate indexes from the "
"index, then use *label* indexing."
msgstr ""

#: ../../user_guide/indexing.rst:617
msgid ""
"This can also be expressed using ``.iloc``, by explicitly getting "
"locations on the indexers, and using *positional* indexing to select "
"things."
msgstr ""

#: ../../user_guide/indexing.rst:624
msgid "For getting *multiple* indexers, using ``.get_indexer``:"
msgstr ""

#: ../../user_guide/indexing.rst:635
msgid "Indexing with list with missing labels is Deprecated"
msgstr ""

#: ../../user_guide/indexing.rst:639
msgid ""
"Starting in 0.21.0, using ``.loc`` or ``[]`` with a list with one or more"
" missing labels, is deprecated, in favor of ``.reindex``."
msgstr ""

#: ../../user_guide/indexing.rst:641
msgid ""
"In prior versions, using ``.loc[list-of-labels]`` would work as long as "
"*at least 1* of the keys was found (otherwise it would raise a "
"``KeyError``). This behavior is deprecated and will show a warning "
"message pointing to this section. The recommended alternative is to use "
"``.reindex()``."
msgstr ""

#: ../../user_guide/indexing.rst:645
msgid "For example."
msgstr ""

#: ../../user_guide/indexing.rst:652
msgid "Selection with all keys found is unchanged."
msgstr ""

#: ../../user_guide/indexing.rst:658
msgid "Previous Behavior"
msgstr ""

#: ../../user_guide/indexing.rst:670
msgid "Current Behavior"
msgstr ""

#: ../../user_guide/indexing.rst:689
msgid "Reindexing"
msgstr ""

#: ../../user_guide/indexing.rst:691
msgid ""
"The idiomatic way to achieve selecting potentially not-found elements is "
"via ``.reindex()``. See also the section on :ref:`reindexing "
"<basics.reindexing>`."
msgstr ""

#: ../../user_guide/indexing.rst:697
msgid ""
"Alternatively, if you want to select only *valid* keys, the following is "
"idiomatic and efficient; it is guaranteed to preserve the dtype of the "
"selection."
msgstr ""

#: ../../user_guide/indexing.rst:704
msgid "Having a duplicated index will raise for a ``.reindex()``:"
msgstr ""

#: ../../user_guide/indexing.rst:716
msgid ""
"Generally, you can intersect the desired labels with the current axis, "
"and then reindex."
msgstr ""

#: ../../user_guide/indexing.rst:723
msgid "However, this would *still* raise if your resulting index is duplicated."
msgstr ""

#: ../../user_guide/indexing.rst:736
msgid "Selecting Random Samples"
msgstr ""

#: ../../user_guide/indexing.rst:738
msgid ""
"A random selection of rows or columns from a Series or DataFrame with the"
" :meth:`~DataFrame.sample` method. The method will sample rows by "
"default, and accepts a specific number of rows/columns to return, or a "
"fraction of rows."
msgstr ""

#: ../../user_guide/indexing.rst:753
msgid ""
"By default, ``sample`` will return each row at most once, but one can "
"also sample with replacement using the ``replace`` option:"
msgstr ""

#: ../../user_guide/indexing.rst:767
msgid ""
"By default, each row has an equal probability of being selected, but if "
"you want rows to have different probabilities, you can pass the "
"``sample`` function sampling weights as ``weights``. These weights can be"
" a list, a NumPy array, or a Series, but they must be of the same length "
"as the object you are sampling. Missing values will be treated as a "
"weight of zero, and inf values are not allowed. If weights do not sum to "
"1, they will be re-normalized by dividing all weights by the sum of the "
"weights. For example:"
msgstr ""

#: ../../user_guide/indexing.rst:781
msgid ""
"When applied to a DataFrame, you can use a column of the DataFrame as "
"sampling weights (provided you are sampling rows and not columns) by "
"simply passing the name of the column as a string."
msgstr ""

#: ../../user_guide/indexing.rst:791
msgid ""
"``sample`` also allows users to sample columns instead of rows using the "
"``axis`` argument."
msgstr ""

#: ../../user_guide/indexing.rst:798
msgid ""
"Finally, one can also set a seed for ``sample``'s random number generator"
" using the ``random_state`` argument, which will accept either an integer"
" (as a seed) or a NumPy RandomState object."
msgstr ""

#: ../../user_guide/indexing.rst:811
msgid "Setting With Enlargement"
msgstr ""

#: ../../user_guide/indexing.rst:813
msgid ""
"The ``.loc/[]`` operations can perform enlargement when setting a non-"
"existent key for that axis."
msgstr ""

#: ../../user_guide/indexing.rst:815
msgid "In the ``Series`` case this is effectively an appending operation."
msgstr ""

#: ../../user_guide/indexing.rst:824
msgid "A ``DataFrame`` can be enlarged on either axis via ``.loc``."
msgstr ""

#: ../../user_guide/indexing.rst:834
msgid "This is like an ``append`` operation on the ``DataFrame``."
msgstr ""

#: ../../user_guide/indexing.rst:844
msgid "Fast scalar value getting and setting"
msgstr ""

#: ../../user_guide/indexing.rst:846
msgid ""
"Since indexing with ``[]`` must handle a lot of cases (single-label "
"access, slicing, boolean indexing, etc.), it has a bit of overhead in "
"order to figure out what you're asking for. If you only want to access a "
"scalar value, the fastest way is to use the ``at`` and ``iat`` methods, "
"which are implemented on all of the data structures."
msgstr ""

#: ../../user_guide/indexing.rst:852
msgid ""
"Similarly to ``loc``, ``at`` provides **label** based scalar lookups, "
"while, ``iat`` provides **integer** based lookups analogously to ``iloc``"
msgstr ""

#: ../../user_guide/indexing.rst:860
msgid "You can also set using these same indexers."
msgstr ""

#: ../../user_guide/indexing.rst:867
msgid "``at`` may enlarge the object in-place as above if the indexer is missing."
msgstr ""

#: ../../user_guide/indexing.rst:875
msgid "Boolean indexing"
msgstr ""

#: ../../user_guide/indexing.rst:879
msgid ""
"Another common operation is the use of boolean vectors to filter the "
"data. The operators are: ``|`` for ``or``, ``&`` for ``and``, and ``~`` "
"for ``not``. These **must** be grouped by using parentheses, since by "
"default Python will evaluate an expression such as ``df.A > 2 & df.B < "
"3`` as ``df.A > (2 & df.B) < 3``, while the desired evaluation order is "
"``(df.A > 2) & (df.B < 3)``."
msgstr ""

#: ../../user_guide/indexing.rst:886
msgid ""
"Using a boolean vector to index a Series works exactly as in a NumPy "
"ndarray:"
msgstr ""

#: ../../user_guide/indexing.rst:896
msgid ""
"You may select rows from a DataFrame using a boolean vector the same "
"length as the DataFrame's index (for example, something derived from one "
"of the columns of the DataFrame):"
msgstr ""

#: ../../user_guide/indexing.rst:904
msgid ""
"List comprehensions and the ``map`` method of Series can also be used to "
"produce more complex criteria:"
msgstr ""

#: ../../user_guide/indexing.rst:924
msgid ""
"With the choice methods :ref:`Selection by Label <indexing.label>`, "
":ref:`Selection by Position <indexing.integer>`, and :ref:`Advanced "
"Indexing <advanced>` you may select along more than one axis using "
"boolean vectors combined with other indexing expressions."
msgstr ""

#: ../../user_guide/indexing.rst:934
msgid "Indexing with isin"
msgstr ""

#: ../../user_guide/indexing.rst:936
msgid ""
"Consider the :meth:`~Series.isin` method of ``Series``, which returns a "
"boolean vector that is true wherever the ``Series`` elements exist in the"
" passed list. This allows you to select rows where one or more columns "
"have values you want:"
msgstr ""

#: ../../user_guide/indexing.rst:947
msgid ""
"The same method is available for ``Index`` objects and is useful for the "
"cases when you don't know which of the sought labels are in fact present:"
msgstr ""

#: ../../user_guide/indexing.rst:957
msgid ""
"In addition to that, ``MultiIndex`` allows selecting a separate level to "
"use in the membership check:"
msgstr ""

#: ../../user_guide/indexing.rst:968
msgid ""
"DataFrame also has an :meth:`~DataFrame.isin` method.  When calling "
"``isin``, pass a set of values as either an array or dict.  If values is "
"an array, ``isin`` returns a DataFrame of booleans that is the same shape"
" as the original DataFrame, with True wherever the element is in the "
"sequence of values."
msgstr ""

#: ../../user_guide/indexing.rst:982
msgid ""
"Oftentimes you'll want to match certain values with certain columns. Just"
" make values a ``dict`` where the key is the column, and the value is a "
"list of items you want to check for."
msgstr ""

#: ../../user_guide/indexing.rst:992
msgid ""
"Combine DataFrame's ``isin`` with the ``any()`` and ``all()`` methods to "
"quickly select subsets of your data that meet a given criteria. To select"
" a row where each column meets its own criterion:"
msgstr ""

#: ../../user_guide/indexing.rst:1007
msgid "The :meth:`~pandas.DataFrame.where` Method and Masking"
msgstr ""

#: ../../user_guide/indexing.rst:1009
msgid ""
"Selecting values from a Series with a boolean vector generally returns a "
"subset of the data. To guarantee that selection output has the same shape"
" as the original data, you can use the ``where`` method in ``Series`` and"
" ``DataFrame``."
msgstr ""

#: ../../user_guide/indexing.rst:1013
msgid "To return only the selected rows:"
msgstr ""

#: ../../user_guide/indexing.rst:1019
msgid "To return a Series of the same shape as the original:"
msgstr ""

#: ../../user_guide/indexing.rst:1025
msgid ""
"Selecting values from a DataFrame with a boolean criterion now also "
"preserves input data shape. ``where`` is used under the hood as the "
"implementation. The code below is equivalent to ``df.where(df < 0)``."
msgstr ""

#: ../../user_guide/indexing.rst:1040
msgid ""
"In addition, ``where`` takes an optional ``other`` argument for "
"replacement of values where the condition is False, in the returned copy."
msgstr ""

#: ../../user_guide/indexing.rst:1047
msgid ""
"You may wish to set values based on some boolean criteria. This can be "
"done intuitively like so:"
msgstr ""

#: ../../user_guide/indexing.rst:1060
msgid ""
"By default, ``where`` returns a modified copy of the data. There is an "
"optional parameter ``inplace`` so that the original data can be modified "
"without creating a copy:"
msgstr ""

#: ../../user_guide/indexing.rst:1072
msgid ""
"The signature for :func:`DataFrame.where` differs from "
":func:`numpy.where`. Roughly ``df1.where(m, df2)`` is equivalent to "
"``np.where(m, df1, df2)``."
msgstr ""

#: ../../user_guide/indexing.rst:1079
msgid "**alignment**"
msgstr ""

#: ../../user_guide/indexing.rst:1081
msgid ""
"Furthermore, ``where`` aligns the input boolean condition (ndarray or "
"DataFrame), such that partial selection with setting is possible. This is"
" analogous to partial setting via ``.loc`` (but on the contents rather "
"than the axis labels)."
msgstr ""

#: ../../user_guide/indexing.rst:1091
msgid ""
"Where can also accept ``axis`` and ``level`` parameters to align the "
"input when performing the ``where``."
msgstr ""

#: ../../user_guide/indexing.rst:1099
msgid "This is equivalent to (but faster than) the following."
msgstr ""

#: ../../user_guide/indexing.rst:1108
msgid ""
"Where can accept a callable as condition and ``other`` arguments. The "
"function must be with one argument (the calling Series or DataFrame) and "
"that returns valid output as condition and ``other`` argument."
msgstr ""

#: ../../user_guide/indexing.rst:1120
msgid "Mask"
msgstr ""

#: ../../user_guide/indexing.rst:1122
msgid ""
":meth:`~pandas.DataFrame.mask` is the inverse boolean operation of "
"``where``."
msgstr ""

#: ../../user_guide/indexing.rst:1132
msgid "The :meth:`~pandas.DataFrame.query` Method"
msgstr ""

#: ../../user_guide/indexing.rst:1134
msgid ""
":class:`~pandas.DataFrame` objects have a :meth:`~pandas.DataFrame.query`"
" method that allows selection using an expression."
msgstr ""

#: ../../user_guide/indexing.rst:1137
msgid ""
"You can get the value of the frame where column ``b`` has values between "
"the values of columns ``a`` and ``c``. For example:"
msgstr ""

#: ../../user_guide/indexing.rst:1152
msgid ""
"Do the same thing but fall back on a named index if there is no column "
"with the name ``a``."
msgstr ""

#: ../../user_guide/indexing.rst:1162
msgid ""
"If instead you don't want to or cannot name your index, you can use the "
"name ``index`` in your query expression:"
msgstr ""

#: ../../user_guide/indexing.rst:1173
msgid ""
"If the name of your index overlaps with a column name, the column name is"
" given precedence. For example,"
msgstr ""

#: ../../user_guide/indexing.rst:1182
msgid ""
"You can still use the index in a query expression by using the special "
"identifier 'index':"
msgstr ""

#: ../../user_guide/indexing.rst:1189
msgid ""
"If for some reason you have a column named ``index``, then you can refer "
"to the index as ``ilevel_0`` as well, but at this point you should "
"consider renaming your columns to something less ambiguous."
msgstr ""

#: ../../user_guide/indexing.rst:1195
msgid ":class:`~pandas.MultiIndex` :meth:`~pandas.DataFrame.query` Syntax"
msgstr ""

#: ../../user_guide/indexing.rst:1197
msgid ""
"You can also use the levels of a ``DataFrame`` with a "
":class:`~pandas.MultiIndex` as if they were columns in the frame:"
msgstr ""

#: ../../user_guide/indexing.rst:1213
msgid ""
"If the levels of the ``MultiIndex`` are unnamed, you can refer to them "
"using special names:"
msgstr ""

#: ../../user_guide/indexing.rst:1223
msgid ""
"The convention is ``ilevel_0``, which means \"index level 0\" for the 0th"
" level of the ``index``."
msgstr ""

#: ../../user_guide/indexing.rst:1228
msgid ":meth:`~pandas.DataFrame.query` Use Cases"
msgstr ""

#: ../../user_guide/indexing.rst:1230
msgid ""
"A use case for :meth:`~pandas.DataFrame.query` is when you have a "
"collection of :class:`~pandas.DataFrame` objects that have a subset of "
"column names (or index levels/names) in common. You can pass the same "
"query to both frames *without* having to specify which frame you're "
"interested in querying"
msgstr ""

#: ../../user_guide/indexing.rst:1245
msgid ":meth:`~pandas.DataFrame.query` Python versus pandas Syntax Comparison"
msgstr ""

#: ../../user_guide/indexing.rst:1247
msgid "Full numpy-like syntax:"
msgstr ""

#: ../../user_guide/indexing.rst:1256
msgid ""
"Slightly nicer by removing the parentheses (by binding making comparison "
"operators bind tighter than ``&`` and ``|``)."
msgstr ""

#: ../../user_guide/indexing.rst:1263
msgid "Use English instead of symbols:"
msgstr ""

#: ../../user_guide/indexing.rst:1269
msgid "Pretty close to how you might write it on paper:"
msgstr ""

#: ../../user_guide/indexing.rst:1276
msgid "The ``in`` and ``not in`` operators"
msgstr ""

#: ../../user_guide/indexing.rst:1278
msgid ""
":meth:`~pandas.DataFrame.query` also supports special use of Python's "
"``in`` and ``not in`` comparison operators, providing a succinct syntax "
"for calling the ``isin`` method of a ``Series`` or ``DataFrame``."
msgstr ""

#: ../../user_guide/indexing.rst:1300
msgid "You can combine this with other expressions for very succinct queries:"
msgstr ""

#: ../../user_guide/indexing.rst:1315
msgid ""
"Note that ``in`` and ``not in`` are evaluated in Python, since "
"``numexpr`` has no equivalent of this operation. However, **only the** "
"``in``/``not in`` **expression itself** is evaluated in vanilla Python. "
"For example, in the expression"
msgstr ""

#: ../../user_guide/indexing.rst:1324
msgid ""
"``(b + c + d)`` is evaluated by ``numexpr`` and *then* the ``in`` "
"operation is evaluated in plain Python. In general, any operations that "
"can be evaluated using ``numexpr`` will be."
msgstr ""

#: ../../user_guide/indexing.rst:1329
msgid "Special use of the ``==`` operator with ``list`` objects"
msgstr ""

#: ../../user_guide/indexing.rst:1331
msgid ""
"Comparing a ``list`` of values to a column using ``==``/``!=`` works "
"similarly to ``in``/``not in``."
msgstr ""

#: ../../user_guide/indexing.rst:1355
msgid "Boolean Operators"
msgstr ""

#: ../../user_guide/indexing.rst:1357
msgid ""
"You can negate boolean expressions with the word ``not`` or the ``~`` "
"operator."
msgstr ""

#: ../../user_guide/indexing.rst:1367
msgid "Of course, expressions can be arbitrarily complex too:"
msgstr ""

#: ../../user_guide/indexing.rst:1384
msgid "Performance of :meth:`~pandas.DataFrame.query`"
msgstr ""

#: ../../user_guide/indexing.rst:1386
msgid ""
"``DataFrame.query()`` using ``numexpr`` is slightly faster than Python "
"for large frames."
msgstr ""

#: ../../user_guide/indexing.rst:1393
msgid ""
"You will only see the performance benefits of using the ``numexpr`` "
"engine with ``DataFrame.query()`` if your frame has more than "
"approximately 200,000 rows."
msgstr ""

#: ../../user_guide/indexing.rst:1399
msgid ""
"This plot was created using a ``DataFrame`` with 3 columns each "
"containing floating point values generated using "
"``numpy.random.randn()``."
msgstr ""

#: ../../user_guide/indexing.rst:1411
msgid "Duplicate Data"
msgstr ""

#: ../../user_guide/indexing.rst:1415
msgid ""
"If you want to identify and remove duplicate rows in a DataFrame,  there "
"are two methods that will help: ``duplicated`` and ``drop_duplicates``. "
"Each takes as an argument the columns to use to identify duplicated rows."
msgstr ""

#: ../../user_guide/indexing.rst:1419
msgid ""
"``duplicated`` returns a boolean vector whose length is the number of "
"rows, and which indicates whether a row is duplicated."
msgstr ""

#: ../../user_guide/indexing.rst:1420
msgid "``drop_duplicates`` removes duplicate rows."
msgstr ""

#: ../../user_guide/indexing.rst:1422
msgid ""
"By default, the first observed row of a duplicate set is considered "
"unique, but each method has a ``keep`` parameter to specify targets to be"
" kept."
msgstr ""

#: ../../user_guide/indexing.rst:1425
msgid ""
"``keep='first'`` (default): mark / drop duplicates except for the first "
"occurrence."
msgstr ""

#: ../../user_guide/indexing.rst:1426
msgid "``keep='last'``: mark / drop duplicates except for the last occurrence."
msgstr ""

#: ../../user_guide/indexing.rst:1427
msgid "``keep=False``: mark  / drop all duplicates."
msgstr ""

#: ../../user_guide/indexing.rst:1442
msgid "Also, you can pass a list of columns to identify duplications."
msgstr ""

#: ../../user_guide/indexing.rst:1449
msgid ""
"To drop duplicates by index value, use ``Index.duplicated`` then perform "
"slicing. The same set of options are available for the ``keep`` "
"parameter."
msgstr ""

#: ../../user_guide/indexing.rst:1466
msgid "Dictionary-like :meth:`~pandas.DataFrame.get` method"
msgstr ""

#: ../../user_guide/indexing.rst:1468
msgid ""
"Each of Series or DataFrame have a ``get`` method which can return a "
"default value."
msgstr ""

#: ../../user_guide/indexing.rst:1478
msgid "The :meth:`~pandas.DataFrame.lookup` Method"
msgstr ""

#: ../../user_guide/indexing.rst:1480
msgid ""
"Sometimes you want to extract a set of values given a sequence of row "
"labels and column labels, and the ``lookup`` method allows for this and "
"returns a NumPy array.  For instance:"
msgstr ""

#: ../../user_guide/indexing.rst:1492
msgid "Index objects"
msgstr ""

#: ../../user_guide/indexing.rst:1494
msgid ""
"The pandas :class:`~pandas.Index` class and its subclasses can be viewed "
"as implementing an *ordered multiset*. Duplicates are allowed. However, "
"if you try to convert an :class:`~pandas.Index` object with duplicate "
"entries into a ``set``, an exception will be raised."
msgstr ""

#: ../../user_guide/indexing.rst:1499
msgid ""
":class:`~pandas.Index` also provides the infrastructure necessary for "
"lookups, data alignment, and reindexing. The easiest way to create an "
":class:`~pandas.Index` directly is to pass a ``list`` or other sequence "
"to :class:`~pandas.Index`:"
msgstr ""

#: ../../user_guide/indexing.rst:1510
msgid "You can also pass a ``name`` to be stored in the index:"
msgstr ""

#: ../../user_guide/indexing.rst:1518
msgid "The name, if set, will be shown in the console display:"
msgstr ""

#: ../../user_guide/indexing.rst:1531
msgid "Setting metadata"
msgstr ""

#: ../../user_guide/indexing.rst:1533
msgid ""
"Indexes are \"mostly immutable\", but it is possible to set and change "
"their metadata, like the index ``name`` (or, for ``MultiIndex``, "
"``levels`` and ``codes``)."
msgstr ""

#: ../../user_guide/indexing.rst:1537
msgid ""
"You can use the ``rename``, ``set_names``, ``set_levels``, and "
"``set_codes`` to set these attributes directly. They default to returning"
" a copy; however, you can specify ``inplace=True`` to have the data "
"change in place."
msgstr ""

#: ../../user_guide/indexing.rst:1541
msgid "See :ref:`Advanced Indexing <advanced>` for usage of MultiIndexes."
msgstr ""

#: ../../user_guide/indexing.rst:1552
msgid ""
"``set_names``, ``set_levels``, and ``set_codes`` also take an optional "
"``level`` argument"
msgstr ""

#: ../../user_guide/indexing.rst:1563
msgid "Set operations on Index objects"
msgstr ""

#: ../../user_guide/indexing.rst:1567
msgid ""
"The two main operations are ``union (|)`` and ``intersection (&)``. These"
" can be directly called as instance methods or used via overloaded "
"operators. Difference is provided via the ``.difference()`` method."
msgstr ""

#: ../../user_guide/indexing.rst:1579
msgid ""
"Also available is the ``symmetric_difference (^)`` operation, which "
"returns elements that appear in either ``idx1`` or ``idx2``, but not in "
"both. This is equivalent to the Index created by "
"``idx1.difference(idx2).union(idx2.difference(idx1))``, with duplicates "
"dropped."
msgstr ""

#: ../../user_guide/indexing.rst:1593
msgid ""
"The resulting index from a set operation will be sorted in ascending "
"order."
msgstr ""

#: ../../user_guide/indexing.rst:1596
msgid "Missing values"
msgstr ""

#: ../../user_guide/indexing.rst:1602
msgid ""
"Even though ``Index`` can hold missing values (``NaN``), it should be "
"avoided if you do not want any unexpected results. For example, some "
"operations exclude missing values implicitly."
msgstr ""

#: ../../user_guide/indexing.rst:1606
msgid "``Index.fillna`` fills missing values with specified scalar value."
msgstr ""

#: ../../user_guide/indexing.rst:1621
msgid "Set / Reset Index"
msgstr ""

#: ../../user_guide/indexing.rst:1623
msgid ""
"Occasionally you will load or create a data set into a DataFrame and want"
" to add an index after you've already done so. There are a couple of "
"different ways."
msgstr ""

#: ../../user_guide/indexing.rst:1628
msgid "Set an index"
msgstr ""

#: ../../user_guide/indexing.rst:1632
msgid ""
"DataFrame has a :meth:`~DataFrame.set_index` method which takes a column "
"name (for a regular ``Index``) or a list of column names (for a "
"``MultiIndex``). To create a new, re-indexed DataFrame:"
msgstr ""

#: ../../user_guide/indexing.rst:1652
msgid ""
"The ``append`` keyword option allow you to keep the existing index and "
"append the given columns to a MultiIndex:"
msgstr ""

#: ../../user_guide/indexing.rst:1661
msgid ""
"Other options in ``set_index`` allow you not drop the index columns or to"
" add the index in-place (without creating a new object):"
msgstr ""

#: ../../user_guide/indexing.rst:1671
msgid "Reset the index"
msgstr ""

#: ../../user_guide/indexing.rst:1673
msgid ""
"As a convenience, there is a new function on DataFrame called "
":meth:`~DataFrame.reset_index` which transfers the index values into the "
"DataFrame's columns and sets a simple integer index. This is the inverse "
"operation of :meth:`~DataFrame.set_index`."
msgstr ""

#: ../../user_guide/indexing.rst:1684
msgid ""
"The output is more similar to a SQL table or a record array. The names "
"for the columns derived from the index are the ones stored in the "
"``names`` attribute."
msgstr ""

#: ../../user_guide/indexing.rst:1687
msgid "You can use the ``level`` keyword to remove only a portion of the index:"
msgstr ""

#: ../../user_guide/indexing.rst:1695
msgid ""
"``reset_index`` takes an optional parameter ``drop`` which if true simply"
" discards the index, instead of putting index values in the DataFrame's "
"columns."
msgstr ""

#: ../../user_guide/indexing.rst:1699
msgid "Adding an ad hoc index"
msgstr ""

#: ../../user_guide/indexing.rst:1701
msgid ""
"If you create an index yourself, you can just assign it to the ``index`` "
"field:"
msgstr ""

#: ../../user_guide/indexing.rst:1710
msgid "Returning a view versus a copy"
msgstr ""

#: ../../user_guide/indexing.rst:1712
msgid ""
"When setting values in a pandas object, care must be taken to avoid what "
"is called ``chained indexing``. Here is an example."
msgstr ""

#: ../../user_guide/indexing.rst:1725
msgid "Compare these two access methods:"
msgstr ""

#: ../../user_guide/indexing.rst:1735
msgid ""
"These both yield the same results, so which should you use? It is "
"instructive to understand the order of operations on these and why method"
" 2 (``.loc``) is much preferred over method 1 (chained ``[]``)."
msgstr ""

#: ../../user_guide/indexing.rst:1738
msgid ""
"``dfmi['one']`` selects the first level of the columns and returns a "
"DataFrame that is singly-indexed. Then another Python operation "
"``dfmi_with_one['second']`` selects the series indexed by ``'second'``. "
"This is indicated by the variable ``dfmi_with_one`` because pandas sees "
"these operations as separate events. e.g. separate calls to "
"``__getitem__``, so it has to treat them as linear operations, they "
"happen one after another."
msgstr ""

#: ../../user_guide/indexing.rst:1743
msgid ""
"Contrast this to ``df.loc[:,('one','second')]`` which passes a nested "
"tuple of ``(slice(None),('one','second'))`` to a single call to "
"``__getitem__``. This allows pandas to deal with this as a single entity."
" Furthermore this order of operations *can* be significantly faster, and "
"allows one to index *both* axes if so desired."
msgstr ""

#: ../../user_guide/indexing.rst:1748
msgid "Why does assignment fail when using chained indexing?"
msgstr ""

#: ../../user_guide/indexing.rst:1750
msgid ""
"The problem in the previous section is just a performance issue. What's "
"up with the ``SettingWithCopy`` warning? We don't **usually** throw "
"warnings around when you do something that might cost a few extra "
"milliseconds!"
msgstr ""

#: ../../user_guide/indexing.rst:1754
msgid ""
"But it turns out that assigning to the product of chained indexing has "
"inherently unpredictable results. To see this, think about how the Python"
" interpreter executes this code:"
msgstr ""

#: ../../user_guide/indexing.rst:1769
msgid "But this code is handled differently:"
msgstr ""

#: ../../user_guide/indexing.rst:1777
msgid ""
"See that ``__getitem__`` in there? Outside of simple cases, it's very "
"hard to predict whether it will return a view or a copy (it depends on "
"the memory layout of the array, about which pandas makes no guarantees), "
"and therefore whether the ``__setitem__`` will modify ``dfmi`` or a "
"temporary object that gets thrown out immediately afterward. **That's** "
"what ``SettingWithCopy`` is warning you about!"
msgstr ""

#: ../../user_guide/indexing.rst:1784
msgid ""
"You may be wondering whether we should be concerned about the ``loc`` "
"property in the first example. But ``dfmi.loc`` is guaranteed to be "
"``dfmi`` itself with modified indexing behavior, so "
"``dfmi.loc.__getitem__`` / ``dfmi.loc.__setitem__`` operate on ``dfmi`` "
"directly. Of course, ``dfmi.loc.__getitem__(idx)`` may be a view or a "
"copy of ``dfmi``."
msgstr ""

#: ../../user_guide/indexing.rst:1790
msgid ""
"Sometimes a ``SettingWithCopy`` warning will arise at times when there's "
"no obvious chained indexing going on. **These** are the bugs that "
"``SettingWithCopy`` is designed to catch! Pandas is probably trying to "
"warn you that you've done this:"
msgstr ""

#: ../../user_guide/indexing.rst:1804
msgid "Yikes!"
msgstr ""

#: ../../user_guide/indexing.rst:1809
msgid "Evaluation order matters"
msgstr ""

#: ../../user_guide/indexing.rst:1811
msgid ""
"When you use chained indexing, the order and type of the indexing "
"operation partially determine whether the result is a slice into the "
"original object, or a copy of the slice."
msgstr ""

#: ../../user_guide/indexing.rst:1815
msgid ""
"Pandas has the ``SettingWithCopyWarning`` because assigning to a copy of "
"a slice is frequently not intentional, but a mistake caused by chained "
"indexing returning a copy where a slice was expected."
msgstr ""

#: ../../user_guide/indexing.rst:1819
msgid ""
"If you would like pandas to be more or less trusting about assignment to "
"a chained indexing expression, you can set the :ref:`option <options>` "
"``mode.chained_assignment`` to one of these values:"
msgstr ""

#: ../../user_guide/indexing.rst:1823
msgid "``'warn'``, the default, means a ``SettingWithCopyWarning`` is printed."
msgstr ""

#: ../../user_guide/indexing.rst:1824
msgid ""
"``'raise'`` means pandas will raise a ``SettingWithCopyException`` you "
"have to deal with."
msgstr ""

#: ../../user_guide/indexing.rst:1826
msgid "``None`` will suppress the warnings entirely."
msgstr ""

#: ../../user_guide/indexing.rst:1839
msgid "This however is operating on a copy and will not work."
msgstr ""

#: ../../user_guide/indexing.rst:1851
msgid "A chained assignment can also crop up in setting in a mixed dtype frame."
msgstr ""

#: ../../user_guide/indexing.rst:1855
msgid "These setting rules apply to all of ``.loc/.iloc``."
msgstr ""

#: ../../user_guide/indexing.rst:1857
msgid "This is the correct access method:"
msgstr ""

#: ../../user_guide/indexing.rst:1865
msgid ""
"This *can* work at times, but it is not guaranteed to, and therefore "
"should be avoided:"
msgstr ""

#: ../../user_guide/indexing.rst:1874
msgid "This will **not** work at all, and so should be avoided:"
msgstr ""

#: ../../user_guide/indexing.rst:1888
msgid ""
"The chained assignment warnings / exceptions are aiming to inform the "
"user of a possibly invalid assignment. There may be false positives; "
"situations where a chained assignment is inadvertently reported."
msgstr ""

