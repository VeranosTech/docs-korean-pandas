# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2008-2014, the pandas development team
# This file is distributed under the same license as the pandas package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: pandas 0.24.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-04-11 11:49+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../user_guide/groupby.rst:3
msgid "{{ header }}"
msgstr ""

#: ../../user_guide/groupby.rst:7
msgid "Group By: split-apply-combine"
msgstr ""

#: ../../user_guide/groupby.rst:9
msgid ""
"By \"group by\" we are referring to a process involving one or more of "
"the following steps:"
msgstr ""

#: ../../user_guide/groupby.rst:12
msgid "**Splitting** the data into groups based on some criteria."
msgstr ""

#: ../../user_guide/groupby.rst:13
msgid "**Applying** a function to each group independently."
msgstr ""

#: ../../user_guide/groupby.rst:14
msgid "**Combining** the results into a data structure."
msgstr ""

#: ../../user_guide/groupby.rst:16
msgid ""
"Out of these, the split step is the most straightforward. In fact, in "
"many situations we may wish to split the data set into groups and do "
"something with those groups. In the apply step, we might wish to do one "
"of the following:"
msgstr ""

#: ../../user_guide/groupby.rst:21
msgid ""
"**Aggregation**: compute a summary statistic (or statistics) for each "
"group. Some examples:"
msgstr ""

#: ../../user_guide/groupby.rst:24
msgid "Compute group sums or means."
msgstr ""

#: ../../user_guide/groupby.rst:25
msgid "Compute group sizes / counts."
msgstr ""

#: ../../user_guide/groupby.rst:27
msgid ""
"**Transformation**: perform some group-specific computations and return a"
" like-indexed object. Some examples:"
msgstr ""

#: ../../user_guide/groupby.rst:30
msgid "Standardize data (zscore) within a group."
msgstr ""

#: ../../user_guide/groupby.rst:31
msgid "Filling NAs within groups with a value derived from each group."
msgstr ""

#: ../../user_guide/groupby.rst:33
msgid ""
"**Filtration**: discard some groups, according to a group-wise "
"computation that evaluates True or False. Some examples:"
msgstr ""

#: ../../user_guide/groupby.rst:36
msgid "Discard data that belongs to groups with only a few members."
msgstr ""

#: ../../user_guide/groupby.rst:37
msgid "Filter out data based on the group sum or mean."
msgstr ""

#: ../../user_guide/groupby.rst:39
msgid ""
"Some combination of the above: GroupBy will examine the results of the "
"apply step and try to return a sensibly combined result if it doesn't fit"
" into either of the above two categories."
msgstr ""

#: ../../user_guide/groupby.rst:43
msgid ""
"Since the set of object instance methods on pandas data structures are "
"generally rich and expressive, we often simply want to invoke, say, a "
"DataFrame function on each group. The name GroupBy should be quite "
"familiar to those who have used a SQL-based tool (or ``itertools``), in "
"which you can write code like:"
msgstr ""

#: ../../user_guide/groupby.rst:54
msgid ""
"We aim to make operations like this natural and easy to express using "
"pandas. We'll address each area of GroupBy functionality then provide "
"some non-trivial examples / use cases."
msgstr ""

#: ../../user_guide/groupby.rst:58
msgid "See the :ref:`cookbook<cookbook.grouping>` for some advanced strategies."
msgstr ""

#: ../../user_guide/groupby.rst:63
msgid "Splitting an object into groups"
msgstr ""

#: ../../user_guide/groupby.rst:65
msgid ""
"pandas objects can be split on any of their axes. The abstract definition"
" of grouping is to provide a mapping of labels to group names. To create "
"a GroupBy object (more on what the GroupBy object is later), you may do "
"the following:"
msgstr ""

#: ../../user_guide/groupby.rst:85
msgid "The mapping can be specified many different ways:"
msgstr ""

#: ../../user_guide/groupby.rst:87
msgid "A Python function, to be called on each of the axis labels."
msgstr ""

#: ../../user_guide/groupby.rst:88
msgid "A list or NumPy array of the same length as the selected axis."
msgstr ""

#: ../../user_guide/groupby.rst:89
msgid "A dict or ``Series``, providing a ``label -> group name`` mapping."
msgstr ""

#: ../../user_guide/groupby.rst:90
msgid ""
"For ``DataFrame`` objects, a string indicating a column to be used to "
"group. Of course ``df.groupby('A')`` is just syntactic sugar for "
"``df.groupby(df['A'])``, but it makes life simpler."
msgstr ""

#: ../../user_guide/groupby.rst:93
msgid ""
"For ``DataFrame`` objects, a string indicating an index level to be used "
"to group."
msgstr ""

#: ../../user_guide/groupby.rst:95
msgid "A list of any of the above things."
msgstr ""

#: ../../user_guide/groupby.rst:97
msgid ""
"Collectively we refer to the grouping objects as the **keys**. For "
"example, consider the following ``DataFrame``:"
msgstr ""

#: ../../user_guide/groupby.rst:102
msgid ""
"A string passed to ``groupby`` may refer to either a column or an index "
"level. If a string matches both a column name and an index level name, a "
"``ValueError`` will be raised."
msgstr ""

#: ../../user_guide/groupby.rst:116
msgid ""
"On a DataFrame, we obtain a GroupBy object by calling "
":meth:`~DataFrame.groupby`. We could naturally group by either the ``A`` "
"or ``B`` columns, or both:"
msgstr ""

#: ../../user_guide/groupby.rst:126
msgid ""
"If we also have a MultiIndex on columns ``A`` and ``B``, we can group by "
"all but the specified columns"
msgstr ""

#: ../../user_guide/groupby.rst:135
msgid ""
"These will split the DataFrame on its index (rows). We could also split "
"by the columns:"
msgstr ""

#: ../../user_guide/groupby.rst:149
msgid ""
"pandas :class:`~pandas.Index` objects support duplicate values. If a non-"
"unique index is used as the group key in a groupby operation, all values "
"for the same index value will be considered to be in one group and thus "
"the output of aggregation functions will only contain unique index "
"values:"
msgstr ""

#: ../../user_guide/groupby.rst:168
msgid ""
"Note that **no splitting occurs** until it's needed. Creating the GroupBy"
" object only verifies that you've passed a valid mapping."
msgstr ""

#: ../../user_guide/groupby.rst:173
msgid ""
"Many kinds of complicated data manipulations can be expressed in terms of"
" GroupBy operations (though can't be guaranteed to be the most "
"efficient). You can get quite creative with the label mapping functions."
msgstr ""

#: ../../user_guide/groupby.rst:180
msgid "GroupBy sorting"
msgstr ""

#: ../../user_guide/groupby.rst:182
msgid ""
"By default the group keys are sorted during the ``groupby`` operation. "
"You may however pass ``sort=False`` for potential speedups:"
msgstr ""

#: ../../user_guide/groupby.rst:191
msgid ""
"Note that ``groupby`` will preserve the order in which *observations* are"
" sorted *within* each group. For example, the groups created by "
"``groupby()`` below are in the order they appeared in the original "
"``DataFrame``:"
msgstr ""

#: ../../user_guide/groupby.rst:206
msgid "GroupBy object attributes"
msgstr ""

#: ../../user_guide/groupby.rst:208
msgid ""
"The ``groups`` attribute is a dict whose keys are the computed unique "
"groups and corresponding values being the axis labels belonging to each "
"group. In the above example we have:"
msgstr ""

#: ../../user_guide/groupby.rst:217
msgid ""
"Calling the standard Python ``len`` function on the GroupBy object just "
"returns the length of the ``groups`` dict, so it is largely just a "
"convenience:"
msgstr ""

#: ../../user_guide/groupby.rst:229
msgid "``GroupBy`` will tab complete column names (and other attributes):"
msgstr ""

#: ../../user_guide/groupby.rst:259
msgid "GroupBy with MultiIndex"
msgstr ""

#: ../../user_guide/groupby.rst:261
msgid ""
"With :ref:`hierarchically-indexed data <advanced.hierarchical>`, it's "
"quite natural to group by one of the levels of the hierarchy."
msgstr ""

#: ../../user_guide/groupby.rst:264
msgid "Let's create a Series with a two-level ``MultiIndex``."
msgstr ""

#: ../../user_guide/groupby.rst:275
msgid "We can then group by one of the levels in ``s``."
msgstr ""

#: ../../user_guide/groupby.rst:282
msgid ""
"If the MultiIndex has names specified, these can be passed instead of the"
" level number:"
msgstr ""

#: ../../user_guide/groupby.rst:289
msgid ""
"The aggregation functions such as ``sum`` will take the level parameter "
"directly. Additionally, the resulting index will be named according to "
"the chosen level:"
msgstr ""

#: ../../user_guide/groupby.rst:297
msgid "Grouping with multiple levels is supported."
msgstr ""

#: ../../user_guide/groupby.rst:316
msgid "Index level names may be supplied as keys."
msgstr ""

#: ../../user_guide/groupby.rst:322
msgid "More on the ``sum`` function and aggregation later."
msgstr ""

#: ../../user_guide/groupby.rst:325
msgid "Grouping DataFrame with Index Levels and Columns"
msgstr ""

#: ../../user_guide/groupby.rst:326
msgid ""
"A DataFrame may be grouped by a combination of columns and index levels "
"by specifying the column names as strings and the index levels as "
"``pd.Grouper`` objects."
msgstr ""

#: ../../user_guide/groupby.rst:343
msgid ""
"The following example groups ``df`` by the ``second`` index level and the"
" ``A`` column."
msgstr ""

#: ../../user_guide/groupby.rst:350
msgid "Index levels may also be specified by name."
msgstr ""

#: ../../user_guide/groupby.rst:358
msgid "Index level names may be specified as keys directly to ``groupby``."
msgstr ""

#: ../../user_guide/groupby.rst:365
msgid "DataFrame column selection in GroupBy"
msgstr ""

#: ../../user_guide/groupby.rst:367
msgid ""
"Once you have created the GroupBy object from a DataFrame, you might want"
" to do something different for each of the columns. Thus, using ``[]`` "
"similar to getting a column from a DataFrame, you can do:"
msgstr ""

#: ../../user_guide/groupby.rst:387
msgid "This is mainly syntactic sugar for the alternative and much more verbose:"
msgstr ""

#: ../../user_guide/groupby.rst:393
msgid ""
"Additionally this method avoids recomputing the internal grouping "
"information derived from the passed key."
msgstr ""

#: ../../user_guide/groupby.rst:399
msgid "Iterating through groups"
msgstr ""

#: ../../user_guide/groupby.rst:401
msgid ""
"With the GroupBy object in hand, iterating through the grouped data is "
"very natural and functions similarly to :py:func:`itertools.groupby`:"
msgstr ""

#: ../../user_guide/groupby.rst:413
msgid "In the case of grouping by multiple keys, the group name will be a tuple:"
msgstr ""

#: ../../user_guide/groupby.rst:422
msgid "See :ref:`timeseries.iterating-label`."
msgstr ""

#: ../../user_guide/groupby.rst:425
msgid "Selecting a group"
msgstr ""

#: ../../user_guide/groupby.rst:427
msgid ""
"A single group can be selected using "
":meth:`~pandas.core.groupby.DataFrameGroupBy.get_group`:"
msgstr ""

#: ../../user_guide/groupby.rst:434
msgid "Or for an object grouped on multiple columns:"
msgstr ""

#: ../../user_guide/groupby.rst:443
msgid "Aggregation"
msgstr ""

#: ../../user_guide/groupby.rst:445
msgid ""
"Once the GroupBy object has been created, several methods are available "
"to perform a computation on the grouped data. These operations are "
"similar to the :ref:`aggregating API <basics.aggregate>`, :ref:`window "
"functions API <stats.aggregate>`, and :ref:`resample API "
"<timeseries.aggregate>`."
msgstr ""

#: ../../user_guide/groupby.rst:450
msgid ""
"An obvious one is aggregation via the "
":meth:`~pandas.core.groupby.DataFrameGroupBy.aggregate` or equivalently "
":meth:`~pandas.core.groupby.DataFrameGroupBy.agg` method:"
msgstr ""

#: ../../user_guide/groupby.rst:462
msgid ""
"As you can see, the result of the aggregation will have the group names "
"as the new index along the grouped axis. In the case of multiple keys, "
"the result is a :ref:`MultiIndex <advanced.hierarchical>` by default, "
"though this can be changed by using the ``as_index`` option:"
msgstr ""

#: ../../user_guide/groupby.rst:474
msgid ""
"Note that you could use the ``reset_index`` DataFrame function to achieve"
" the same result as the column names are stored in the resulting "
"``MultiIndex``:"
msgstr ""

#: ../../user_guide/groupby.rst:481
msgid ""
"Another simple aggregation example is to compute the size of each group. "
"This is included in GroupBy as the ``size`` method. It returns a Series "
"whose index are the group names and whose values are the sizes of each "
"group."
msgstr ""

#: ../../user_guide/groupby.rst:495
msgid ""
"Aggregation functions **will not** return the groups that you are "
"aggregating over if they are named *columns*, when ``as_index=True``, the"
" default. The grouped columns will be the **indices** of the returned "
"object."
msgstr ""

#: ../../user_guide/groupby.rst:499
msgid ""
"Passing ``as_index=False`` **will** return the groups that you are "
"aggregating over, if they are named *columns*."
msgstr ""

#: ../../user_guide/groupby.rst:502
msgid ""
"Aggregating functions are the ones that reduce the dimension of the "
"returned objects. Some common aggregating functions are tabulated below:"
msgstr ""

#: ../../user_guide/groupby.rst:1
msgid "Function"
msgstr ""

#: ../../user_guide/groupby.rst:1
msgid "Description"
msgstr ""

#: ../../user_guide/groupby.rst:1
msgid ":meth:`~pd.core.groupby.DataFrameGroupBy.mean`"
msgstr ""

#: ../../user_guide/groupby.rst:1
msgid "Compute mean of groups"
msgstr ""

#: ../../user_guide/groupby.rst:1
msgid ":meth:`~pd.core.groupby.DataFrameGroupBy.sum`"
msgstr ""

#: ../../user_guide/groupby.rst:1
msgid "Compute sum of group values"
msgstr ""

#: ../../user_guide/groupby.rst:1
msgid ":meth:`~pd.core.groupby.DataFrameGroupBy.size`"
msgstr ""

#: ../../user_guide/groupby.rst:1
msgid "Compute group sizes"
msgstr ""

#: ../../user_guide/groupby.rst:1
msgid ":meth:`~pd.core.groupby.DataFrameGroupBy.count`"
msgstr ""

#: ../../user_guide/groupby.rst:1
msgid "Compute count of group"
msgstr ""

#: ../../user_guide/groupby.rst:1
msgid ":meth:`~pd.core.groupby.DataFrameGroupBy.std`"
msgstr ""

#: ../../user_guide/groupby.rst:1
msgid "Standard deviation of groups"
msgstr ""

#: ../../user_guide/groupby.rst:1
msgid ":meth:`~pd.core.groupby.DataFrameGroupBy.var`"
msgstr ""

#: ../../user_guide/groupby.rst:1
msgid "Compute variance of groups"
msgstr ""

#: ../../user_guide/groupby.rst:1
msgid ":meth:`~pd.core.groupby.DataFrameGroupBy.sem`"
msgstr ""

#: ../../user_guide/groupby.rst:1
msgid "Standard error of the mean of groups"
msgstr ""

#: ../../user_guide/groupby.rst:1
msgid ":meth:`~pd.core.groupby.DataFrameGroupBy.describe`"
msgstr ""

#: ../../user_guide/groupby.rst:1
msgid "Generates descriptive statistics"
msgstr ""

#: ../../user_guide/groupby.rst:1
msgid ":meth:`~pd.core.groupby.DataFrameGroupBy.first`"
msgstr ""

#: ../../user_guide/groupby.rst:1
msgid "Compute first of group values"
msgstr ""

#: ../../user_guide/groupby.rst:1
msgid ":meth:`~pd.core.groupby.DataFrameGroupBy.last`"
msgstr ""

#: ../../user_guide/groupby.rst:1
msgid "Compute last of group values"
msgstr ""

#: ../../user_guide/groupby.rst:1
msgid ":meth:`~pd.core.groupby.DataFrameGroupBy.nth`"
msgstr ""

#: ../../user_guide/groupby.rst:1
msgid "Take nth value, or a subset if n is a list"
msgstr ""

#: ../../user_guide/groupby.rst:1
msgid ":meth:`~pd.core.groupby.DataFrameGroupBy.min`"
msgstr ""

#: ../../user_guide/groupby.rst:1
msgid "Compute min of group values"
msgstr ""

#: ../../user_guide/groupby.rst:1
msgid ":meth:`~pd.core.groupby.DataFrameGroupBy.max`"
msgstr ""

#: ../../user_guide/groupby.rst:1
msgid "Compute max of group values"
msgstr ""

#: ../../user_guide/groupby.rst:525
msgid ""
"The aggregating functions above will exclude NA values. Any function "
"which reduces a :class:`Series` to a scalar value is an aggregation "
"function and will work, a trivial example is ``df.groupby('A').agg(lambda"
" ser: 1)``. Note that :meth:`~pd.core.groupby.DataFrameGroupBy.nth` can "
"act as a reducer *or* a filter, see :ref:`here <groupby.nth>`."
msgstr ""

#: ../../user_guide/groupby.rst:534
msgid "Applying multiple functions at once"
msgstr ""

#: ../../user_guide/groupby.rst:536
msgid ""
"With grouped ``Series`` you can also pass a list or dict of functions to "
"do aggregation with, outputting a DataFrame:"
msgstr ""

#: ../../user_guide/groupby.rst:544
msgid ""
"On a grouped ``DataFrame``, you can pass a list of functions to apply to "
"each column, which produces an aggregated result with a hierarchical "
"index:"
msgstr ""

#: ../../user_guide/groupby.rst:552
msgid ""
"The resulting aggregations are named for the functions themselves. If you"
" need to rename, then you can add in a chained operation for a ``Series``"
" like this:"
msgstr ""

#: ../../user_guide/groupby.rst:562
msgid "For a grouped ``DataFrame``, you can rename in a similar manner:"
msgstr ""

#: ../../user_guide/groupby.rst:573
msgid "Applying different functions to DataFrame columns"
msgstr ""

#: ../../user_guide/groupby.rst:575
msgid ""
"By passing a dict to ``aggregate`` you can apply a different aggregation "
"to the columns of a DataFrame:"
msgstr ""

#: ../../user_guide/groupby.rst:583
msgid ""
"The function names can also be strings. In order for a string to be valid"
" it must be either implemented on GroupBy or available via "
":ref:`dispatching <groupby.dispatch>`:"
msgstr ""

#: ../../user_guide/groupby.rst:593
msgid ""
"If you pass a dict to ``aggregate``, the ordering of the output columns "
"is non-deterministic. If you want to be sure the output columns will be "
"in a specific order, you can use an ``OrderedDict``.  Compare the output "
"of the following two commands:"
msgstr ""

#: ../../user_guide/groupby.rst:607
msgid "Cython-optimized aggregation functions"
msgstr ""

#: ../../user_guide/groupby.rst:609
msgid ""
"Some common aggregations, currently only ``sum``, ``mean``, ``std``, and "
"``sem``, have optimized Cython implementations:"
msgstr ""

#: ../../user_guide/groupby.rst:617
msgid ""
"Of course ``sum`` and ``mean`` are implemented on pandas objects, so the "
"above code would work even without the special versions via dispatching "
"(see below)."
msgstr ""

#: ../../user_guide/groupby.rst:623
msgid "Transformation"
msgstr ""

#: ../../user_guide/groupby.rst:625
msgid ""
"The ``transform`` method returns an object that is indexed the same (same"
" size) as the one being grouped. The transform function must:"
msgstr ""

#: ../../user_guide/groupby.rst:628
msgid ""
"Return a result that is either the same size as the group chunk or "
"broadcastable to the size of the group chunk (e.g., a scalar, "
"``grouped.transform(lambda x: x.iloc[-1])``)."
msgstr ""

#: ../../user_guide/groupby.rst:631
msgid ""
"Operate column-by-column on the group chunk.  The transform is applied to"
" the first group chunk using chunk.apply."
msgstr ""

#: ../../user_guide/groupby.rst:633
msgid ""
"Not perform in-place operations on the group chunk. Group chunks should "
"be treated as immutable, and changes to a group chunk may produce "
"unexpected results. For example, when using ``fillna``, ``inplace`` must "
"be ``False`` (``grouped.transform(lambda x: x.fillna(inplace=False))``)."
msgstr ""

#: ../../user_guide/groupby.rst:637
msgid ""
"(Optionally) operates on the entire group chunk. If this is supported, a "
"fast path is used starting from the *second* chunk."
msgstr ""

#: ../../user_guide/groupby.rst:640
msgid "For example, suppose we wished to standardize the data within each group:"
msgstr ""

#: ../../user_guide/groupby.rst:654
msgid ""
"We would expect the result to now have mean 0 and standard deviation 1 "
"within each group, which we can easily check:"
msgstr ""

#: ../../user_guide/groupby.rst:669
msgid "We can also visually compare the original and transformed data sets."
msgstr ""

#: ../../user_guide/groupby.rst:678
msgid ""
"Transformation functions that have lower dimension outputs are broadcast "
"to match the shape of the input array."
msgstr ""

#: ../../user_guide/groupby.rst:685
msgid ""
"Alternatively, the built-in methods could be used to produce the same "
"outputs."
msgstr ""

#: ../../user_guide/groupby.rst:694
msgid ""
"Another common data transform is to replace missing data with the group "
"mean."
msgstr ""

#: ../../user_guide/groupby.rst:720
msgid ""
"We can verify that the group means have not changed in the transformed "
"data and that the transformed data contains no NAs."
msgstr ""

#: ../../user_guide/groupby.rst:736
msgid ""
"Some functions will automatically transform the input when applied to a "
"GroupBy object, but returning an object of the same shape as the "
"original. Passing ``as_index=False`` will not affect these transformation"
" methods."
msgstr ""

#: ../../user_guide/groupby.rst:740
msgid "For example: ``fillna, ffill, bfill, shift.``."
msgstr ""

#: ../../user_guide/groupby.rst:750
msgid "New syntax to window and resample operations"
msgstr ""

#: ../../user_guide/groupby.rst:753
msgid ""
"Working with the resample, expanding or rolling operations on the groupby"
" level used to require the application of helper functions. However, now "
"it is possible to use ``resample()``, ``expanding()`` and ``rolling()`` "
"as methods on groupbys."
msgstr ""

#: ../../user_guide/groupby.rst:758
msgid ""
"The example below will apply the ``rolling()`` method on the samples of "
"the column B based on the groups of column A."
msgstr ""

#: ../../user_guide/groupby.rst:770
msgid ""
"The ``expanding()`` method will accumulate a given operation (``sum()`` "
"in the example) for all the members of each particular group."
msgstr ""

#: ../../user_guide/groupby.rst:779
msgid ""
"Suppose you want to use the ``resample()`` method to get a daily "
"frequency in each group of your dataframe and wish to complete the "
"missing values with the ``ffill()`` method."
msgstr ""

#: ../../user_guide/groupby.rst:796
msgid "Filtration"
msgstr ""

#: ../../user_guide/groupby.rst:798
msgid ""
"The ``filter`` method returns a subset of the original object. Suppose we"
" want to take only elements that belong to groups with a group sum "
"greater than 2."
msgstr ""

#: ../../user_guide/groupby.rst:807
msgid ""
"The argument of ``filter`` must be a function that, applied to the group "
"as a whole, returns ``True`` or ``False``."
msgstr ""

#: ../../user_guide/groupby.rst:810
msgid ""
"Another useful operation is filtering out elements that belong to groups "
"with only a couple members."
msgstr ""

#: ../../user_guide/groupby.rst:818
msgid ""
"Alternatively, instead of dropping the offending groups, we can return a "
"like-indexed objects where the groups that do not pass the filter are "
"filled with NaNs."
msgstr ""

#: ../../user_guide/groupby.rst:826
msgid ""
"For DataFrames with multiple columns, filters should explicitly specify a"
" column as the filter criterion."
msgstr ""

#: ../../user_guide/groupby.rst:835
msgid ""
"Some functions when applied to a groupby object will act as a **filter** "
"on the input, returning a reduced shape of the original (and potentially "
"eliminating groups), but with the index unchanged. Passing "
"``as_index=False`` will not affect these transformation methods."
msgstr ""

#: ../../user_guide/groupby.rst:839
msgid "For example: ``head, tail``."
msgstr ""

#: ../../user_guide/groupby.rst:849
msgid "Dispatching to instance methods"
msgstr ""

#: ../../user_guide/groupby.rst:851
msgid ""
"When doing an aggregation or transformation, you might just want to call "
"an instance method on each data group. This is pretty easy to do by "
"passing lambda functions:"
msgstr ""

#: ../../user_guide/groupby.rst:860
msgid ""
"But, it's rather verbose and can be untidy if you need to pass additional"
" arguments. Using a bit of metaprogramming cleverness, GroupBy now has "
"the ability to \"dispatch\" method calls to the groups:"
msgstr ""

#: ../../user_guide/groupby.rst:868
msgid ""
"What is actually happening here is that a function wrapper is being "
"generated. When invoked, it takes any passed arguments and invokes the "
"function with any arguments on each group (in the above example, the "
"``std`` function). The results are then combined together much in the "
"style of ``agg`` and ``transform`` (it actually uses ``apply`` to infer "
"the gluing, documented next). This enables some operations to be carried "
"out rather succinctly:"
msgstr ""

#: ../../user_guide/groupby.rst:884
msgid ""
"In this example, we chopped the collection of time series into yearly "
"chunks then independently called :ref:`fillna <missing_data.fillna>` on "
"the groups."
msgstr ""

#: ../../user_guide/groupby.rst:888
msgid ""
"The ``nlargest`` and ``nsmallest`` methods work on ``Series`` style "
"groupbys:"
msgstr ""

#: ../../user_guide/groupby.rst:901
msgid "Flexible ``apply``"
msgstr ""

#: ../../user_guide/groupby.rst:903
msgid ""
"Some operations on the grouped data might not fit into either the "
"aggregate or transform categories. Or, you may simply want GroupBy to "
"infer how to combine the results. For these, use the ``apply`` function, "
"which can be substituted for both ``aggregate`` and ``transform`` in many"
" standard use cases. However, ``apply`` can handle some exceptional use "
"cases, for example:"
msgstr ""

#: ../../user_guide/groupby.rst:917
msgid "The dimension of the returned result can also change:"
msgstr ""

#: ../../user_guide/groupby.rst:930
msgid ""
"``apply`` on a Series can operate on a returned value from the applied "
"function, that is itself a series, and possibly upcast the result to a "
"DataFrame:"
msgstr ""

#: ../../user_guide/groupby.rst:945
msgid ""
"``apply`` can act as a reducer, transformer, *or* filter function, "
"depending on exactly what is passed to it. So depending on the path "
"taken, and exactly what you are grouping. Thus the grouped columns(s) may"
" be included in the output as well as set the indices."
msgstr ""

#: ../../user_guide/groupby.rst:951
msgid "Other useful features"
msgstr ""

#: ../../user_guide/groupby.rst:954
msgid "Automatic exclusion of \"nuisance\" columns"
msgstr ""

#: ../../user_guide/groupby.rst:956
msgid "Again consider the example DataFrame we've been looking at:"
msgstr ""

#: ../../user_guide/groupby.rst:962
msgid ""
"Suppose we wish to compute the standard deviation grouped by the ``A`` "
"column. There is a slight problem, namely that we don't care about the "
"data in column ``B``. We refer to this as a \"nuisance\" column. If the "
"passed aggregation function can't be applied to some columns, the "
"troublesome columns will be (silently) dropped. Thus, this does not pose "
"any problems:"
msgstr ""

#: ../../user_guide/groupby.rst:972
msgid ""
"Note that ``df.groupby('A').colname.std().`` is more efficient than "
"``df.groupby('A').std().colname``, so if the result of an aggregation "
"function is only interesting over one column (here ``colname``), it may "
"be filtered *before* applying the aggregation function."
msgstr ""

#: ../../user_guide/groupby.rst:978
msgid ""
"Any object column, also if it contains numerical values such as "
"``Decimal`` objects, is considered as a \"nuisance\" columns. They are "
"excluded from aggregate functions automatically in groupby."
msgstr ""

#: ../../user_guide/groupby.rst:982
msgid ""
"If you do wish to include decimal or object columns in an aggregation "
"with other non-nuisance data types, you must do so explicitly."
msgstr ""

#: ../../user_guide/groupby.rst:1009
msgid "Handling of (un)observed Categorical values"
msgstr ""

#: ../../user_guide/groupby.rst:1011
msgid ""
"When using a ``Categorical`` grouper (as a single grouper, or as part of "
"multiple groupers), the ``observed`` keyword controls whether to return a"
" cartesian product of all possible groupers values (``observed=False``) "
"or only those that are observed groupers (``observed=True``)."
msgstr ""

#: ../../user_guide/groupby.rst:1015
msgid "Show all values:"
msgstr ""

#: ../../user_guide/groupby.rst:1023
msgid "Show only the observed values:"
msgstr ""

#: ../../user_guide/groupby.rst:1031
msgid ""
"The returned dtype of the grouped will *always* include *all* of the "
"categories that were grouped."
msgstr ""

#: ../../user_guide/groupby.rst:1043
msgid "NA and NaT group handling"
msgstr ""

#: ../../user_guide/groupby.rst:1045
msgid ""
"If there are any NaN or NaT values in the grouping key, these will be "
"automatically excluded. In other words, there will never be an \"NA "
"group\" or \"NaT group\". This was not the case in older versions of "
"pandas, but users were generally discarding the NA group anyway (and "
"supporting it was an implementation headache)."
msgstr ""

#: ../../user_guide/groupby.rst:1052
msgid "Grouping with ordered factors"
msgstr ""

#: ../../user_guide/groupby.rst:1054
msgid ""
"Categorical variables represented as instance of pandas's ``Categorical``"
" class can be used as group keys. If so, the order of the levels will be "
"preserved:"
msgstr ""

#: ../../user_guide/groupby.rst:1068
msgid "Grouping with a Grouper specification"
msgstr ""

#: ../../user_guide/groupby.rst:1070
msgid ""
"You may need to specify a bit more data to properly group. You can use "
"the ``pd.Grouper`` to provide this local control."
msgstr ""

#: ../../user_guide/groupby.rst:1093
msgid ""
"Groupby a specific column with the desired frequency. This is like "
"resampling."
msgstr ""

#: ../../user_guide/groupby.rst:1099
msgid ""
"You have an ambiguous specification in that you have a named index and a "
"column that could be potential groupers."
msgstr ""

#: ../../user_guide/groupby.rst:1112
msgid "Taking the first rows of each group"
msgstr ""

#: ../../user_guide/groupby.rst:1114
msgid ""
"Just like for a DataFrame or Series you can call head and tail on a "
"groupby:"
msgstr ""

#: ../../user_guide/groupby.rst:1126
msgid "This shows the first or last n rows from each group."
msgstr ""

#: ../../user_guide/groupby.rst:1131
msgid "Taking the nth row of each group"
msgstr ""

#: ../../user_guide/groupby.rst:1133
msgid ""
"To select from a DataFrame or Series the nth item, use "
":meth:`~pd.core.groupby.DataFrameGroupBy.nth`. This is a reduction "
"method, and will return a single row (or no row) per group if you pass an"
" int for n:"
msgstr ""

#: ../../user_guide/groupby.rst:1146
msgid ""
"If you want to select the nth not-null item, use the ``dropna`` kwarg. "
"For a DataFrame this should be either ``'any'`` or ``'all'`` just like "
"you would pass to dropna:"
msgstr ""

#: ../../user_guide/groupby.rst:1160
msgid ""
"As with other methods, passing ``as_index=False``, will achieve a "
"filtration, which returns the grouped row."
msgstr ""

#: ../../user_guide/groupby.rst:1170
msgid ""
"You can also select multiple rows from each group by specifying multiple "
"nth values as a list of ints."
msgstr ""

#: ../../user_guide/groupby.rst:1180
msgid "Enumerate group items"
msgstr ""

#: ../../user_guide/groupby.rst:1182
msgid ""
"To see the order in which each row appears within its group, use the "
"``cumcount`` method:"
msgstr ""

#: ../../user_guide/groupby.rst:1197
msgid "Enumerate groups"
msgstr ""

#: ../../user_guide/groupby.rst:1201
msgid ""
"To see the ordering of the groups (as opposed to the order of rows within"
" a group given by ``cumcount``) you can use "
":meth:`~pandas.core.groupby.DataFrameGroupBy.ngroup`."
msgstr ""

#: ../../user_guide/groupby.rst:1207
msgid ""
"Note that the numbers given to the groups match the order in which the "
"groups would be seen when iterating over the groupby object, not the "
"order they are first observed."
msgstr ""

#: ../../user_guide/groupby.rst:1221
msgid "Plotting"
msgstr ""

#: ../../user_guide/groupby.rst:1223
msgid ""
"Groupby also works with some plotting methods.  For example, suppose we "
"suspect that some features in a DataFrame may differ by group, in this "
"case, the values in column 1 where the group is \"B\" are 3 higher on "
"average."
msgstr ""

#: ../../user_guide/groupby.rst:1234
msgid "We can easily visualize this with a boxplot:"
msgstr ""

#: ../../user_guide/groupby.rst:1242
msgid ""
"The result of calling ``boxplot`` is a dictionary whose keys are the "
"values of our grouping column ``g`` (\"A\" and \"B\"). The values of the "
"resulting dictionary can be controlled by the ``return_type`` keyword of "
"``boxplot``. See the :ref:`visualization "
"documentation<visualization.box>` for more."
msgstr ""

#: ../../user_guide/groupby.rst:1249
msgid ""
"For historical reasons, ``df.groupby(\"g\").boxplot()`` is not equivalent"
" to ``df.boxplot(by=\"g\")``. See :ref:`here<visualization.box.return>` "
"for an explanation."
msgstr ""

#: ../../user_guide/groupby.rst:1256
msgid "Piping function calls"
msgstr ""

#: ../../user_guide/groupby.rst:1260
msgid ""
"Similar to the functionality provided by ``DataFrame`` and ``Series``, "
"functions that take ``GroupBy`` objects can be chained together using a "
"``pipe`` method to allow for a cleaner, more readable syntax. To read "
"about ``.pipe`` in general terms, see :ref:`here <basics.pipe>`."
msgstr ""

#: ../../user_guide/groupby.rst:1265
msgid ""
"Combining ``.groupby`` and ``.pipe`` is often useful when you need to "
"reuse GroupBy objects."
msgstr ""

#: ../../user_guide/groupby.rst:1268
msgid ""
"As an example, imagine having a DataFrame with columns for stores, "
"products, revenue and quantity sold. We'd like to do a groupwise "
"calculation of *prices* (i.e. revenue/quantity) per store and per "
"product. We could do this in a multi-step operation, but expressing it in"
" terms of piping can make the code more readable. First we set the data:"
msgstr ""

#: ../../user_guide/groupby.rst:1284
msgid "Now, to find prices per store/product, we can simply do:"
msgstr ""

#: ../../user_guide/groupby.rst:1292
msgid ""
"Piping can also be expressive when you want to deliver a grouped object "
"to some arbitrary function, for example:"
msgstr ""

#: ../../user_guide/groupby.rst:1302
msgid ""
"where ``mean`` takes a GroupBy object and finds the mean of the Revenue "
"and Quantity columns respectively for each Store-Product combination. The"
" ``mean`` function can be any function that takes in a GroupBy object; "
"the ``.pipe`` will pass the GroupBy object as a parameter into the "
"function you specify."
msgstr ""

#: ../../user_guide/groupby.rst:1308
msgid "Examples"
msgstr ""

#: ../../user_guide/groupby.rst:1311
msgid "Regrouping by factor"
msgstr ""

#: ../../user_guide/groupby.rst:1313
msgid ""
"Regroup columns of a DataFrame according to their sum, and sum the "
"aggregated ones."
msgstr ""

#: ../../user_guide/groupby.rst:1325
msgid "Multi-column factorization"
msgstr ""

#: ../../user_guide/groupby.rst:1327
msgid ""
"By using :meth:`~pandas.core.groupby.DataFrameGroupBy.ngroup`, we can "
"extract information about the groups in a way similar to "
":func:`factorize` (as described further in the :ref:`reshaping API "
"<reshaping.factorize>`) but which applies naturally to multiple columns "
"of mixed type and different sources. This can be useful as an "
"intermediate categorical-like step in processing, when the relationships "
"between the group rows are more important than their content, or as input"
" to an algorithm which only accepts the integer encoding. (For more "
"information about support in pandas for full categorical data, see the "
":ref:`Categorical introduction <categorical>` and the :ref:`API "
"documentation <api.arrays.categorical>`.)"
msgstr ""

#: ../../user_guide/groupby.rst:1350
msgid "Groupby by Indexer to 'resample' data"
msgstr ""

#: ../../user_guide/groupby.rst:1352
msgid ""
"Resampling produces new hypothetical samples (resamples) from already "
"existing observed data or from a model that generates data. These new "
"samples are similar to the pre-existing samples."
msgstr ""

#: ../../user_guide/groupby.rst:1354
msgid ""
"In order to resample to work on indices that are non-datetimelike, the "
"following procedure can be utilized."
msgstr ""

#: ../../user_guide/groupby.rst:1356
msgid ""
"In the following examples, **df.index // 5** returns a binary array which"
" is used to determine what gets selected for the groupby operation."
msgstr ""

#: ../../user_guide/groupby.rst:1358
msgid ""
"The below example shows how we can downsample by consolidation of samples"
" into fewer samples. Here by using **df.index // 5**, we are aggregating "
"the samples in bins. By applying **std()** function, we aggregate the "
"information contained in many samples into a small subset of values which"
" is their standard deviation thereby reducing the number of samples."
msgstr ""

#: ../../user_guide/groupby.rst:1368
msgid "Returning a Series to propagate names"
msgstr ""

#: ../../user_guide/groupby.rst:1370
msgid ""
"Group DataFrame columns, compute a set of metrics and return a named "
"Series. The Series name is used as the name for the column index. This is"
" especially useful in conjunction with reshaping operations such as "
"stacking in which the column index name will be used as the name of the "
"inserted column:"
msgstr ""

